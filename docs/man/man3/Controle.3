.TH "Controle" 3 "Sexta, 17 de Setembro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Controle
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Controle\&.h>\fP
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "\fBControle\fP ()"
.br
.ti -1c
.RI "void \fBcomputeTranslationalControl\fP ()"
.br
.ti -1c
.RI "void \fBcomputeRotationalControl\fP ()"
.br
.ti -1c
.RI "void \fBcomputeRotationalTarget\fP ()"
.br
.ti -1c
.RI "void \fBvirtualCommandToMotorCommand\fP ()"
.br
.ti -1c
.RI "void \fBvirtualCommandToMotorRpm\fP ()"
.br
.ti -1c
.RI "void \fBcontrolLoop\fP ()"
.br
.in -1c
.SS "Campos de Dados"

.in +1c
.ti -1c
.RI "int \fBminimalDigitalCommand\fP = 7700"
.br
.ti -1c
.RI "int \fBmaximalDigitalCommand\fP = 15400"
.br
.ti -1c
.RI "float \fBgravidade\fP = 9\&.80f"
.br
.ti -1c
.RI "uint8_t \fBindex_alt\fP = 1"
.br
.ti -1c
.RI "\fBDrone\fP * \fBdrone\fP"
.br
.ti -1c
.RI "\fBSdre\fP * \fBsdre\fP"
.br
.ti -1c
.RI "Eigen::Vector3f \fBrI\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBr\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBqa\fP = Eigen::MatrixXf::Zero(4, 2)"
.br
.ti -1c
.RI "Eigen::Vector4f \fBqe\fP {1, 0, 0, 0}"
.br
.ti -1c
.RI "Eigen::Vector3f \fBwa\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "float \fBpsi\fP = 0\&.0f"
.br
.ti -1c
.RI "float \fBdpsi\fP = 0\&.0f"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBLt\fP = Eigen::MatrixXf::Identity(3, 3)"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBLs_G\fP = Eigen::MatrixXf::Identity(3, 3)"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBRt\fP = \&.5 * Eigen::MatrixXf::Identity(3, 3)"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBQt\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBRr\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBQr\fP"
.br
.ti -1c
.RI "Eigen::Vector3f \fBut\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f \fBu\fP = Eigen::Vector4f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4i \fBmotorCommands\fP = Eigen::Vector4i::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f \fBrotationsOfMotors\fP = Eigen::Vector4f::Zero()"
.br
.ti -1c
.RI "float \fBoldPsi\fP = 0"
.br
.ti -1c
.RI "bool \fBnegativeq0\fP = false"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 26 do arquivo Controle\&.h\&.
.SH "Construtores e Destrutores"
.PP 
.SS "Controle::Controle ()"
Control class\&. 
.PP
Definição na linha 14 do arquivo Controle\&.cpp\&.
.PP
.nf
14                    {
15 #ifdef __GNUC__
16   string _folderPlace = "include/CONTROLE/";
17   Qt = csvLeia<Eigen::MatrixXf>(_folderPlace + "Qt_66");
18   Rt = csvLeia<Eigen::MatrixXf>(_folderPlace + "Rt_66");
19   Qr = csvLeia<Eigen::MatrixXf>(_folderPlace + "Qr");
20   Rr = csvLeia<Eigen::MatrixXf>(_folderPlace + "Rr");
21 #endif
22   drone = new Drone(0\&.04);
23   u(0) = drone->massa * gravidade;
24   ut(2) = drone->massa * gravidade;
25   qa(0, 1) = 1\&.0f;
26   /*Calcula o ganho para controle da dinâmica translacional*/
27   sdre = new Sdre(drone->matAT, drone->matBT, Qt, Rt);
28   sdre->updateControl();
29   Lt = sdre->L;
30   Ls_G = sdre->ricObj->Ls * sdre->G;
31   PRINT_MAT(sdre->closeLoopEig());
32   sdre->~Sdre();
33 
34   /* Instância a classe SDRE para computo da dinâmica rotacional\&.*/
35   sdre = new Sdre(drone->matAR, drone->matBR, Qr, Rr);
36 }
.fi
.PP
Referencias Sdre::closeLoopEig(), Sdre::G, gravidade, Sdre::L, Riccati::Ls, Ls_G, Lt, PRINT_MAT, qa, Qr, Qt, Sdre::ricObj, Rr, Rt, sdre, u, Sdre::updateControl(), ut e Sdre::~Sdre()\&.
.SH "Funções membros"
.PP 
.SS "void Controle::computeRotationalControl ()"
Computa do controle da dinâmica rotacional\&. 
.PP
Definição na linha 84 do arquivo Controle\&.cpp\&.
.PP
.nf
84                                         {
85   sdre->updateControl();
86   Eigen::VectorXf _r(6), _x(6);
87   // #ifdef __GNUC__
88   qe = (ekf::S_l(drone->q))\&.transpose() * qa\&.col(index_alt);
89   // #endif
90   _x << qe\&.tail(3), drone->w - wa;
91   // _x << drone->q\&.tail(3), drone->w;
92   // _r << qa\&.block(1, index_alt, 3, 1), wa;
93   // u\&.tail(3) = -sdre->L * _x + sdre->ricObj->Ls * sdre->G * Qr * _r;
94 
95   u\&.tail(3) = -sdre->L * _x; // + sdre->ricObj->Ls * sdre->G * Qr * _r;
96 }
.fi
.PP
Referencias index_alt, Sdre::L, qa, qe, ekf::S_l(), sdre, u, Sdre::updateControl() e wa\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::computeRotationalTarget ()"
attention ut(2) já comtém a gravidade adicionada no método &computeTranslationalControl
.PP
Definição na linha 51 do arquivo Controle\&.cpp\&.
.PP
.nf
51                                        {
54   float qc0 = sqrtf(0\&.5 * (ut(2) / u(0) + 1\&.0f));
55   float cosPhi_2 = cosf(0\&.5f * psi);
56   float sinPhi_2 = sinf(0\&.5f * psi);
57   /* Calculo do quaternion de atitude alvo\&.*/
58   qa(0, index_alt) = qc0 * cosPhi_2;
59   qa(1, index_alt) =
60       (ut(1) * cosPhi_2 - ut(0) * sinPhi_2) * \&.5f / (-u(0)) / qc0;
61   qa(2, index_alt) = (ut(0) * cosPhi_2 + ut(1) * sinPhi_2) * \&.5f / u(0) / qc0;
62   qa(3, index_alt) = qc0 * sinPhi_2;
63   // Continuidade do quaternion de atitude\&.
64   // if (isless(qa\&.col(index_alt)\&.dot(qa\&.col(1 - index_alt)), 0\&.0f)) {
65   //   qa\&.col(index_alt) *= -1\&.0f;
66   // }
67   // if (isless(qa\&.col(index_alt)\&.dot(drone->q), 0\&.0f)) {
68   //   qa\&.col(index_alt) *= -1\&.0f;
69   // }
70   // Atualiza a flag da parte escalar do quatenrion alvo\&.
71   (qa(0, index_alt)) < 0\&.0f ? negativeq0 = true : negativeq0 = false;
72   // Calcula a velocidade ângular\&.
73   wa = 2\&.0f / drone->dt * (ekf::Q_l(qa\&.col(1 - index_alt)))\&.transpose() *
74        qa\&.col(index_alt);
75   // Eigen::Vector3f _wg = 2\&.0f / drone->dt *
76   //                       (ekf::Q_r(qa\&.col(1 - index_alt)))\&.transpose() *
77   //                       qa\&.col(index_alt);
78   // wa = ekf::rotateVectorWithQuaternion_Conjugate(drone->q, _wg);
79   u(0) *= drone->massa;
80 }
.fi
.PP
Referencias index_alt, negativeq0, psi, ekf::Q_l(), qa, u, ut e wa\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::computeTranslationalControl ()"
Calcula o controle de tranlação\&. 
.PP
Definição na linha 41 do arquivo Controle\&.cpp\&.
.PP
.nf
41                                            { /* */
42   index_alt = 1 - index_alt;
43   Eigen::VectorXf _x(6);
44   _x << drone->p - rI, drone->v - r;
45   ut = -Lt * _x; // + Ls_G * r;
46   // ut = -Lt * (drone->v - r); // + Ls_G * r;
47   ut(2) -= gravidade;
48   // u(0) = -ut\&.norm() * drone->massa;
49   u(0) = -ut\&.norm(); // * drone->massa;
50 }
.fi
.PP
Referencias gravidade, index_alt, Lt, r, rI, u e ut\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::controlLoop ()"
Loop de controle\&. 
.PP
Definição na linha 118 do arquivo Controle\&.cpp\&.
.PP
.nf
118                            {
119   // atualiza as matriz com os valores de q e wb
120   drone->updateStateMatrices(negativeq0);
121   computeTranslationalControl();
122   computeRotationalTarget();
123   computeRotationalControl();
124   virtualCommandToMotorCommand();
125 #ifdef __GNUC__
126   //  Na aplicação embarcda esta etapana não eh necessária\&.
127   virtualCommandToMotorRpm();
128 #endif
129 }
.fi
.PP
Referencias computeRotationalControl(), computeRotationalTarget(), computeTranslationalControl(), negativeq0, virtualCommandToMotorCommand() e virtualCommandToMotorRpm()\&.
.SS "void Controle::virtualCommandToMotorCommand ()"
Converte a tração e os momentos em valores digitais de entrada do ESC na classe #Motores\&.h 
.PP
\fBObservação\fP
.RS 4
: Esta funcao liminta os 
.RE
.PP

.PP
Definição na linha 102 do arquivo Controle\&.cpp\&.
.PP
.nf
102                                             {
103   motorCommands =
104       (drone->Hinv * ((drone->Jinv * u)\&.cwiseSqrt() - drone->h))\&.cast<int>();
105   motorCommands = motorCommands\&.array()
106                       \&.min(maximalDigitalCommand)
107                       \&.max(minimalDigitalCommand)
108                       \&.matrix();
109 }
.fi
.PP
Referencias maximalDigitalCommand, minimalDigitalCommand, motorCommands e u\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::virtualCommandToMotorRpm ()"

.PP
Definição na linha 110 do arquivo Controle\&.cpp\&.
.PP
.nf
110                                         { /* */
111   // rotationsOfMotors << (drone->Jinv * u)\&.array()\&.sqrt()\&.matrix();
112   rotationsOfMotors << drone->H * (motorCommands\&.cast<float>()) + drone->h;
113   u = drone->J * rotationsOfMotors\&.array()\&.square()\&.matrix();
114 }
.fi
.PP
Referencias motorCommands, rotationsOfMotors e u\&.
.PP
Referenciado(a) por controlLoop()\&.
.SH "Campos"
.PP 
.SS "float Controle::dpsi = 0\&.0f"
Velocidade Psi alvo 
.PP
Definição na linha 51 do arquivo Controle\&.h\&.
.SS "\fBDrone\fP* Controle::drone"

.PP
Definição na linha 34 do arquivo Controle\&.h\&.
.SS "float Controle::gravidade = 9\&.80f"

.PP
Definição na linha 32 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl() e Controle()\&.
.SS "uint8_t Controle::index_alt = 1"

.PP
Definição na linha 33 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget() e computeTranslationalControl()\&.
.SS "Eigen::MatrixXf Controle::Ls_G = Eigen::MatrixXf::Identity(3, 3)"

.PP
Definição na linha 54 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "Eigen::MatrixXf Controle::Lt = Eigen::MatrixXf::Identity(3, 3)"
Matriz Ganho de Kalman\&. u = -L * x da dinâmica translacional 
.PP
Definição na linha 53 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl() e Controle()\&.
.SS "int Controle::maximalDigitalCommand = 15400"

.PP
Definição na linha 31 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorCommand()\&.
.SS "int Controle::minimalDigitalCommand = 7700"

.PP
Definição na linha 30 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorCommand()\&.
.SS "Eigen::Vector4i Controle::motorCommands = Eigen::Vector4i::Zero()"
Comandos digitais 
.PP
Definição na linha 79 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorCommand() e virtualCommandToMotorRpm()\&.
.SS "bool Controle::negativeq0 = false"

.PP
Definição na linha 91 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget() e controlLoop()\&.
.SS "float Controle::oldPsi = 0"

.PP
Definição na linha 83 do arquivo Controle\&.h\&.
.SS "float Controle::psi = 0\&.0f"
Ponteiros de velocidade angular
.PP
Psi alvo 
.PP
Definição na linha 48 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget()\&.
.SS "Eigen::MatrixXf Controle::qa = Eigen::MatrixXf::Zero(4, 2)"
Quaternion alvo de atitude 
.PP
Definição na linha 41 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget() e Controle()\&.
.SS "Eigen::Vector4f Controle::qe {1, 0, 0, 0}"

.PP
Definição na linha 42 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl()\&.
.SS "Eigen::MatrixXf Controle::Qr"
\fBValor inicial:\fP
.PP
.nf
=
      2 * (Eigen::VectorXf(6) << 1, 1, 1, \&.1, \&.1, \&.1)\&.finished()\&.asDiagonal()
.fi
Matriz de ponderação do estado rotacional\&. 
.PP
Definição na linha 65 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "Eigen::MatrixXf Controle::Qt"
\fBValor inicial:\fP
.PP
.nf
=
      50 * (Eigen::VectorXf(6) << 1, 1, 1, 1, 1, 1)\&.finished()\&.asDiagonal()
.fi
Matriz de ponderação do estado translacional\&. 
.PP
Definição na linha 58 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "Eigen::Vector3f Controle::r = Eigen::Vector3f::Zero()"
Referência de velocidade tranlacional 
.PP
Definição na linha 39 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl()\&.
.SS "Eigen::Vector3f Controle::rI = Eigen::Vector3f::Zero()"
Integral da referência de velocidade tranlacional 
.PP
Definição na linha 37 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl()\&.
.SS "Eigen::Vector4f Controle::rotationsOfMotors = Eigen::Vector4f::Zero()"
Vetor de rotação dos motores 
.PP
Definição na linha 81 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorRpm()\&.
.SS "Eigen::MatrixXf Controle::Rr"
\fBValor inicial:\fP
.PP
.nf
=
      \&.01 * (Eigen::VectorXf(3) << 1, 1, 1)\&.finished()\&.asDiagonal()
.fi
Matriz de ponderação do controle rotacional\&. 
.PP
Definição na linha 61 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "Eigen::MatrixXf Controle::Rt = \&.5 * Eigen::MatrixXf::Identity(3, 3)"
Matriz de ponderação do controle translacional\&. 
.PP
Definição na linha 56 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "\fBSdre\fP* Controle::sdre"

.PP
Definição na linha 35 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl() e Controle()\&.
.SS "Eigen::Vector4f Controle::u = Eigen::Vector4f::Zero()"
Vetor de controle da dinâmica rotacional \fI/ Eigen::Vector3f ur = Eigen::Vector3f::Zero(); /\fP! Vetor de tração específica e momentos no corpo\&. 
.PP
\fBObservação\fP
.RS 4
que a tração já esta considerando a massa\&. 
.RE
.PP

.PP
Definição na linha 77 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget(), computeTranslationalControl(), Controle(), virtualCommandToMotorCommand() e virtualCommandToMotorRpm()\&.
.SS "Eigen::Vector3f Controle::ut = Eigen::Vector3f::Zero()"
Vetor de controle da dinâmica translacional 
.PP
Definição na linha 71 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget(), computeTranslationalControl() e Controle()\&.
.SS "Eigen::Vector3f Controle::wa = Eigen::Vector3f::Zero()"
Velocidade angular alvo 
.PP
Definição na linha 44 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl() e computeRotationalTarget()\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
