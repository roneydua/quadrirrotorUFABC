.TH "Controle" 3 "Sábado, 20 de Novembro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Controle
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Controle\&.h>\fP
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "\fBControle\fP (float discreteTime)"
.br
.RI "Construct a new \fBControle\fP:: \fBControle\fP object\&. "
.ti -1c
.RI "void \fBcomputeTranslationalControl\fP ()"
.br
.ti -1c
.RI "void \fBcomputeRotationalControl\fP ()"
.br
.ti -1c
.RI "void \fBcomputeRotationalTarget\fP ()"
.br
.ti -1c
.RI "void \fBvirtualCommandToMotorCommand\fP ()"
.br
.ti -1c
.RI "void \fBvirtualCommandToMotorRpm\fP ()"
.br
.ti -1c
.RI "void \fBcontrolLoop\fP ()"
.br
.RI "Loop de controle das duas dinâmicas\&. "
.in -1c
.SS "Campos de Dados"

.in +1c
.ti -1c
.RI "Eigen::Vector3f \fBeulerTarget\fP"
.br
.ti -1c
.RI "int \fBminimalDigitalCommand\fP = 7700"
.br
.ti -1c
.RI "int \fBmaximalDigitalCommand\fP = 15400"
.br
.ti -1c
.RI "float \fBgravidade\fP = 9\&.80f"
.br
.ti -1c
.RI "uint8_t \fBindex_alt\fP = 1"
.br
.ti -1c
.RI "\fBDrone\fP * \fBdrone\fP"
.br
.ti -1c
.RI "\fBSdre\fP * \fBsdre\fP"
.br
.ti -1c
.RI "Eigen::Vector3f \fBr\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Matrix< float, 4, 2 > \fBqa\fP = Eigen::Matrix<float, 4, 2>::Zero(4, 2)"
.br
.ti -1c
.RI "Eigen::Vector4f \fBqe\fP {1, 0, 0, 0}"
.br
.ti -1c
.RI "Eigen::Vector3f \fBwa\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "float \fBpsi\fP = 0\&.0f"
.br
.ti -1c
.RI "float \fBdiffPsi\fP = 0\&.0f"
.br
.ti -1c
.RI "Eigen::Vector3f \fBrI\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Matrix< float, 3, 6 > \fBLt\fP = Eigen::MatrixXf::Zero(3, 6)"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBQt\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBRt\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBRr\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBQr\fP"
.br
.ti -1c
.RI "Eigen::Vector3f \fBut\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f \fBu\fP = Eigen::Vector4f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4i \fBmotorCommands\fP = Eigen::Vector4i::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f \fBrotationsOfMotors\fP = Eigen::Vector4f::Zero()"
.br
.ti -1c
.RI "float \fBoldPsi\fP = 0"
.br
.ti -1c
.RI "bool \fBnegative_q0\fP = false"
.br
.ti -1c
.RI "float \fBTSum\fP = 10\&.0f"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 30 do arquivo Controle\&.h\&.
.SH "Construtores e Destrutores"
.PP 
.SS "Controle::Controle (float discreteTime)"

.PP
Construct a new \fBControle\fP:: \fBControle\fP object\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIdiscreteTime\fP intervalo de tempo de discretização em seconds 
.RE
.PP

.PP
Definição na linha 17 do arquivo Controle\&.cpp\&.
.PP
.nf
17                                      {
18 #ifdef __XTENSA__
19   printf("Nucleo do Controle: %d\n", xPortGetCoreID());
20   vTaskDelay(2000);
21 #endif
22 #if defined(DEBUG_CONTROL) && defined(LOAD_GAINS)
23   // Para debugar diversos valores de ganho este trecho pode ser descomentado
24   // mas
25   //     as variáveis Qt,
26   //     Rt,
27   //     Qr e Rr devem deixar de ser constantes\&.
28   string _folderPlace = "include/CONTROLE/";
29 #ifdef INTEGRAL_CONTROL
30   Qt = csvLeia<Eigen::MatrixXf>(_folderPlace + "Qt_INTEGRAL\&.csv");
31   Rt = csvLeia<Eigen::MatrixXf>(_folderPlace + "Rt_INTEGRAL\&.csv");
32 #else
33   Qt = csvLeia<Eigen::MatrixXf>(_folderPlace + "Qt\&.csv");
34   Rt = csvLeia<Eigen::MatrixXf>(_folderPlace + "Rt\&.csv");
35 
36 #endif
37   Qr = csvLeia<Eigen::MatrixXf>(_folderPlace + "Qr\&.csv");
38   Rr = csvLeia<Eigen::MatrixXf>(_folderPlace + "Rr\&.csv");
39 #endif
40   drone = new Drone(discreteTime);
41   u(0) = drone->massa * gravidade;
42   ut(2) = drone->massa * gravidade;
43   qa(0, 1) = 1\&.0f;
44 /*Calcula o ganho para controle da dinâmica translacional*/
45 #ifdef INTEGRAL_CONTROL
46   sdre = new Sdre(drone->matAT, drone->matBT, Qt, Rt);
47 #else
48   Eigen::MatrixXf matAt_temp = drone->matAT\&.bottomRightCorner(3, 3);
49   Eigen::MatrixXf matBt_temp = drone->matBT\&.bottomRightCorner(3, 3);
50   sdre = new Sdre(matAt_temp, matBt_temp, Qt, Rt);
51 #endif
52   // força a convergência inicial
53   sdre->ricObj->dareInteration(1e-5, 10000);
54   sdre->updateControl();
55   Lt = sdre->L;
56   Eigen::MatrixXcf eigenValuesTranslacional = sdre->closeLoopEig();
57   PRINT_MAT(drone->matAT);
58   PRINT_MAT(drone->matBT);
59   PRINT_MAT(eigenValuesTranslacional);
60   sdre->~Sdre();
61   /* Instância a classe SDRE para computo da dinâmica rotacional\&.*/
62   sdre = new Sdre(drone->matAR, drone->matBR, Qr, Rr);
63   ekf::calc_psi(psi, drone->q);
64 #ifdef DEBUG_CONTROL
65   PRINT_MAT(Qt);
66   PRINT_MAT(Rt);
67   PRINT_MAT(Qr);
68   PRINT_MAT(Rr);
69 #endif
70 }
.fi
.PP
Referencias ekf::calc_psi(), Sdre::closeLoopEig(), Riccati::dareInteration(), gravidade, Sdre::L, Lt, PRINT_MAT, psi, qa, Qr, Qt, Sdre::ricObj, Rr, Rt, sdre, u, Sdre::updateControl(), ut e Sdre::~Sdre()\&.
.SH "Funções membros"
.PP 
.SS "void Controle::computeRotationalControl ()"
Computa do controle da dinâmica rotacional\&. 
.PP
Definição na linha 116 do arquivo Controle\&.cpp\&.
.PP
.nf
116                                         {
117   sdre->updateControl();
118   //  Eigen::VectorXf _r(6), _x(6);
119   Eigen::VectorXf _x(6);
120   qe = (ekf::S_l(drone->q))\&.transpose() * qa\&.col(index_alt);
121   // _qI = ;
122   if (negative_q0) {
123     _x << qe\&.tail(3), drone->w - wa;
124   } else {
125     _x << -qe\&.tail(3), drone->w - wa;
126   }
127   u\&.tail(3) = -sdre->L * _x;
128 }
.fi
.PP
Referencias index_alt, Sdre::L, negative_q0, qa, qe, ekf::S_l(), sdre, u, Sdre::updateControl() e wa\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::computeRotationalTarget ()"
attention ut(2) já contém a gravidade adicionada no método &computeTranslationalControl
.PP
Definição na linha 90 do arquivo Controle\&.cpp\&.
.PP
.nf
90                                        {
93   psi += diffPsi * drone->dt;
94   float qc0 = sqrtf(0\&.5f * (ut(2) / u(0) + 1\&.0f));
95   float cosPhi_2 = cosf(0\&.5f * psi);
96   float sinPhi_2 = sinf(0\&.5f * psi);
97   /* Calculo do quaternion de atitude alvo\&.*/
98 
99   qa(0, index_alt) = qc0 * cosPhi_2;
100   qa(1, index_alt) =
101       (ut(1) * cosPhi_2 - ut(0) * sinPhi_2) * \&.5f / (-u(0)) / qc0;
102   qa(2, index_alt) = (ut(0) * cosPhi_2 + ut(1) * sinPhi_2) * \&.5f / u(0) / qc0;
103   qa(3, index_alt) = qc0 * sinPhi_2;
104   // Atualiza a flag da parte escalar do quaternion alvo\&.
105   (qa(0, index_alt)) < 0\&.0f ? negative_q0 = true : negative_q0 = false;
106   // Calcula a velocidade angular\&.
107   wa = 2\&.0f / drone->dt * (ekf::Q_l(qa\&.col(1 - index_alt)))\&.transpose() *
108        qa\&.col(index_alt);
109 
110   ekf::quaternion2Euler(eulerTarget, qa\&.col(index_alt));
111   u(0) *= drone->massa;
112 }
.fi
.PP
Referencias diffPsi, eulerTarget, index_alt, negative_q0, psi, ekf::Q_l(), qa, ekf::quaternion2Euler(), u, ut e wa\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::computeTranslationalControl ()"
Calcula o controle de translação\&. 
.PP
Definição na linha 75 do arquivo Controle\&.cpp\&.
.PP
.nf
75                                            { /* */
76   index_alt = 1 - index_alt;
77 #ifdef INTEGRAL_CONTROL
78   Eigen::VectorXf _x(6);
79   rI += r * drone->dt;
80   _x << drone->p - rI, drone->v - r;
81   ut = -Lt * _x; // + Ls_G * r;
82 #else
83   ut = -Lt * (drone->v - r); // + Ls_G * r;
84 #endif
85   ut(2) -= gravidade;
86   // Tração local
87 
88   u(0) = -ut\&.norm(); // * drone->massa;
89 }
.fi
.PP
Referencias gravidade, index_alt, Lt, r, rI, u e ut\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::controlLoop ()"

.PP
Loop de controle das duas dinâmicas\&. 
.PP
Definição na linha 152 do arquivo Controle\&.cpp\&.
.PP
.nf
152                            {
153   // atualiza as matriz com os valores de q e wb
154   drone->updateStateMatrices(negative_q0);
155   computeTranslationalControl();
156   computeRotationalTarget();
157   computeRotationalControl();
158   virtualCommandToMotorCommand();
159 #ifndef __XTENSA__
160   //  Na aplicação embarcada esta etapa não eh necessária\&.
161   virtualCommandToMotorRpm();
162 #endif
163 }
.fi
.PP
Referencias computeRotationalControl(), computeRotationalTarget(), computeTranslationalControl(), negative_q0, virtualCommandToMotorCommand() e virtualCommandToMotorRpm()\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "void Controle::virtualCommandToMotorCommand ()"
Converte a tração e os momentos em valores digitais de entrada do ESC na classe #Motores\&.h 
.PP
\fBObservação\fP
.RS 4
: Esta funcao limita os 
.RE
.PP

.PP
Definição na linha 134 do arquivo Controle\&.cpp\&.
.PP
.nf
134                                             {
135   motorCommands =
136       (drone->HInverse * ((drone->JInverse * u)\&.cwiseSqrt() - drone->h))
137           \&.cast<int>();
138   motorCommands = motorCommands\&.array()
139                       \&.min(maximalDigitalCommand)
140                       \&.max(minimalDigitalCommand)
141                       \&.matrix();
142 }
.fi
.PP
Referencias maximalDigitalCommand, minimalDigitalCommand, motorCommands e u\&.
.PP
Referenciado(a) por controlLoop()\&.
.SS "void Controle::virtualCommandToMotorRpm ()"

.PP
Definição na linha 143 do arquivo Controle\&.cpp\&.
.PP
.nf
143                                         { /* */
144   // rotationsOfMotors << (drone->JInvese * u)\&.array()\&.sqrt()\&.matrix();
145   rotationsOfMotors << drone->H * (motorCommands\&.cast<float>()) + drone->h;
146   u = drone->J * rotationsOfMotors\&.array()\&.square()\&.matrix();
147 }
.fi
.PP
Referencias motorCommands, rotationsOfMotors e u\&.
.PP
Referenciado(a) por controlLoop()\&.
.SH "Campos"
.PP 
.SS "float Controle::diffPsi = 0\&.0f"
Velocidade Psi alvo 
.PP
Definição na linha 56 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget() e xTaskContol()\&.
.SS "\fBDrone\fP* Controle::drone"

.PP
Definição na linha 41 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "Eigen::Vector3f Controle::eulerTarget"

.PP
Definição na linha 36 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget() e xTaskContol()\&.
.SS "float Controle::gravidade = 9\&.80f"

.PP
Definição na linha 39 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl() e Controle()\&.
.SS "uint8_t Controle::index_alt = 1"

.PP
Definição na linha 40 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget(), computeTranslationalControl() e xTaskContol()\&.
.SS "Eigen::Matrix<float, 3, 6> Controle::Lt = Eigen::MatrixXf::Zero(3, 6)"
Matriz Ganho de Kalman\&. u = -L * x da dinâmica translacional 
.PP
Definição na linha 61 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl() e Controle()\&.
.SS "int Controle::maximalDigitalCommand = 15400"

.PP
Definição na linha 38 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorCommand()\&.
.SS "int Controle::minimalDigitalCommand = 7700"

.PP
Definição na linha 37 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorCommand() e xTaskContol()\&.
.SS "Eigen::Vector4i Controle::motorCommands = Eigen::Vector4i::Zero()"
Comandos digitais 
.PP
Definição na linha 93 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorCommand(), virtualCommandToMotorRpm() e xTaskContol()\&.
.SS "bool Controle::negative_q0 = false"

.PP
Definição na linha 105 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget() e controlLoop()\&.
.SS "float Controle::oldPsi = 0"

.PP
Definição na linha 97 do arquivo Controle\&.h\&.
.SS "float Controle::psi = 0\&.0f"
Ponteiros de velocidade angular
.PP
Psi alvo 
.PP
Definição na linha 53 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget() e Controle()\&.
.SS "Eigen::Matrix<float, 4, 2> Controle::qa = Eigen::Matrix<float, 4, 2>::Zero(4, 2)"
Quaternion alvo de atitude 
.PP
Definição na linha 46 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget(), Controle() e xTaskContol()\&.
.SS "Eigen::Vector4f Controle::qe {1, 0, 0, 0}"
Quaternio de erro de atitude 
.PP
Definição na linha 48 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl()\&.
.SS "Eigen::MatrixXf Controle::Qr"
\fBValor inicial:\fP
.PP
.nf
= (Eigen::VectorXf(6) << 1e1, 1e1, 1e1, 1e1, 1e1, 1e1)
                           \&.finished()
                           \&.asDiagonal()
.fi
Matriz de ponderação do estado rotacional\&. 
.PP
Definição na linha 82 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle() e xTaskContol()\&.
.SS "Eigen::MatrixXf Controle::Qt"
\fBValor inicial:\fP
.PP
.nf
=
      (Eigen::VectorXf(6) << 5, 5, 5, 3, 3, 3)\&.finished()\&.asDiagonal()
.fi
Matriz de ponderação do estado translacional\&. 
.PP
Definição na linha 63 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "Eigen::Vector3f Controle::r = Eigen::Vector3f::Zero()"
Referência de velocidade translacional 
.PP
Definição na linha 44 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl() e xTaskContol()\&.
.SS "Eigen::Vector3f Controle::rI = Eigen::Vector3f::Zero()"
Integral da referência de velocidade translacional 
.PP
Definição na linha 59 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeTranslationalControl() e xTaskContol()\&.
.SS "Eigen::Vector4f Controle::rotationsOfMotors = Eigen::Vector4f::Zero()"
Vetor de rotação dos motores 
.PP
Definição na linha 95 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por virtualCommandToMotorRpm()\&.
.SS "Eigen::MatrixXf Controle::Rr"
\fBValor inicial:\fP
.PP
.nf
=
      (Eigen::Vector3f() << 1e1, 1e1, 1e1)\&.finished()\&.asDiagonal()
.fi
Matriz de ponderação do controle rotacional\&. 
.PP
Definição na linha 79 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "Eigen::MatrixXf Controle::Rt"
\fBValor inicial:\fP
.PP
.nf
=
      (Eigen::Vector3f() << 1e1, 1e1, 1e1)\&.finished()\&.asDiagonal()
.fi
Matriz de ponderação do controle translacional\&. 
.PP
Definição na linha 75 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por Controle()\&.
.SS "\fBSdre\fP* Controle::sdre"

.PP
Definição na linha 42 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl() e Controle()\&.
.SS "float Controle::TSum = 10\&.0f"

.PP
Definição na linha 106 do arquivo Controle\&.h\&.
.SS "Eigen::Vector4f Controle::u = Eigen::Vector4f::Zero()"
Vetor de tração específica e momentos no corpo\&. 
.PP
\fBObservação\fP
.RS 4
que a tração já esta considerando a massa\&. 
.RE
.PP

.PP
Definição na linha 91 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget(), computeTranslationalControl(), Controle(), virtualCommandToMotorCommand(), virtualCommandToMotorRpm() e xTaskContol()\&.
.SS "Eigen::Vector3f Controle::ut = Eigen::Vector3f::Zero()"
Vetor de controle da dinâmica translacional 
.PP
Definição na linha 87 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalTarget(), computeTranslationalControl(), Controle() e xTaskContol()\&.
.SS "Eigen::Vector3f Controle::wa = Eigen::Vector3f::Zero()"
Velocidade angular alvo 
.PP
Definição na linha 50 do arquivo Controle\&.h\&.
.PP
Referenciado(a) por computeRotationalControl(), computeRotationalTarget() e xTaskContol()\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
