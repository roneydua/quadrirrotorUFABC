.TH "METODOSCALIBRACAO" 3 "Segunda, 25 de Outubro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
METODOSCALIBRACAO
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <METODOSCALIBRACAO\&.h>\fP
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "int \fBcalibracaoGeometrica\fP (MatrixXf &\fBdata\fP, Matrix3f &sF, Vector3f &bias, float moduloCampo)"
.br
.ti -1c
.RI "int \fBcalibracaoAcelerometro\fP (Matrix3f &sF, int16_t(&bias)[3], MatrixXf \fBdata\fP)"
.br
.ti -1c
.RI "int \fBcalibracaoAcelerometro\fP (Matrix3f &sF, Vector3f &bias, MatrixXf \fBdata\fP)"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 26 do arquivo METODOSCALIBRACAO\&.h\&.
.SH "Funções membros"
.PP 
.SS "int METODOSCALIBRACAO::calibracaoAcelerometro (Matrix3f & sF, int16_t(&) bias[3], MatrixXf data)\fC [inline]\fP"
Calibração do acelerômetro\&. Os valores compensador sao obtidos: \fBYc = sF * (Ym - bias)\fP Ym: medidas diretas do sensor Yc: meddias compensadas 
.PP
\fBParâmetros\fP
.RS 4
\fIsF\fP (MatriX3f) Referência da matrix que contem corrige os fatores de escala e dos desalinhamentos\&. 
.br
\fIbias\fP (int16_t array) 
.br
\fIdata\fP Medidas para calibração de dimensão n3 
.RE
.PP
\fBRetorna\fP
.RS 4
1 para positivo e 0 para a falha\&. 
.RE
.PP

.PP
Definição na linha 104 do arquivo METODOSCALIBRACAO\&.h\&.
.PP
.nf
104                                                                               {
105     // data eh uma matrix com N x 3, sendo N o numero de medidas coletadas
106     if (data\&.rows() == 3) {
107       data\&.transposeInPlace();
108     }
109     int indice;
110     int N = data\&.rows();
111     MatrixXf Y = MatrixXf::Zero(N, 3);
112     MatrixXf w = MatrixXf::Ones(N, 4);
113     MatrixXf X = MatrixXf::Zero(4, 3);
114     Vector3f _bias;
115     for (int var = 0; var < N; var++) {
116       data\&.row(var)\&.maxCoeff(&indice);
117       if (data(var, indice) > 1000\&.0f) {
118         Y(var, indice) = 9\&.786171951281709f;
119         w\&.row(var) << data\&.row(var), 1\&.0;
120       } else {
121         data\&.row(var)\&.minCoeff(&indice);
122         Y(var, indice) = -9\&.786171951281709f;
123         w\&.row(var) << data\&.row(var), 1\&.0;
124       }
125     }
126     X = w\&.colPivHouseholderQr()\&.solve(Y);
127     X\&.transposeInPlace();
128 #ifndef __GNUC__
129     for (int i = 0; i < X\&.rows(); ++i) {
130       for (int j = 0; j < X\&.cols(); ++j) {
131         if (isnan(X(i, j)) || isinf(X(i, j))) {
132           return 0;
133         }
134       }
135     }
136 #endif
137     sF = X\&.block(0, 0, 3, 3);
138     _bias = -sF\&.inverse() * X\&.col(3);
139     // bias
140     // bias = -X\&.col(3);
141     // bias[0] = (int16_t)_bias[0];
142     // bias[1] = (int16_t)_bias[1];
143     // bias[2] = (int16_t)_bias[2];
144     return 1;
145   }
.fi
.PP
Referencias data\&.
.SS "int METODOSCALIBRACAO::calibracaoAcelerometro (Matrix3f & sF, Vector3f & bias, MatrixXf data)\fC [inline]\fP"
Calibração do acelerômetro\&. Os valores compensador sao obtidos: \fBYc = sF * (Ym - bias)\fP Ym: medidas diretas do sensor Yc: meddias compensadas 
.PP
\fBParâmetros\fP
.RS 4
\fIsF\fP (MatriX3f) Referência da matrix que contem corrige os fatores de escala e dos desalinhamentos\&. 
.br
\fIbias\fP (Vector3f) Referência do bias\&. 
.br
\fIdata\fP Medidas para calibração de dimensão n3 
.RE
.PP
\fBRetorna\fP
.RS 4
1 para positivo e 0 para a falha\&. 
.RE
.PP

.PP
Definição na linha 157 do arquivo METODOSCALIBRACAO\&.h\&.
.PP
.nf
157                                                                           {
158     // data eh uma matrix com N x 3, sendo N o numero de medidas coletadas
159     if (data\&.rows() == 3) {
160       data\&.transposeInPlace();
161     }
162     int indice;
163     int N = data\&.rows();
164     MatrixXf Y = MatrixXf::Zero(N, 3);
165     MatrixXf w = MatrixXf::Ones(N, 4);
166     MatrixXf X = MatrixXf::Zero(4, 3);
167     Vector3f _bias;
168     for (int var = 0; var < N; var++) {
169       data\&.row(var)\&.maxCoeff(&indice);
170       if (data(var, indice) > 1000\&.0f) {
171         Y(var, indice) = 9\&.786171951281709f;
172         w\&.row(var) << data\&.row(var), 1\&.0;
173       } else {
174         data\&.row(var)\&.minCoeff(&indice);
175         Y(var, indice) = -9\&.786171951281709f;
176         w\&.row(var) << data\&.row(var), 1\&.0;
177       }
178     }
179     X = w\&.colPivHouseholderQr()\&.solve(Y);
180     X\&.transposeInPlace();
181 #ifndef __GNUC__
182     for (int i = 0; i < X\&.rows(); ++i) {
183       for (int j = 0; j < X\&.cols(); ++j) {
184         if (isnan(X(i, j)) || isinf(X(i, j))) {
185           return 0;
186         }
187       }
188     }
189 #endif
190     sF = X\&.block(0, 0, 3, 3);
191     bias = X\&.col(3);
192     return 1;
193   }
.fi
.PP
Referencias data\&.
.SS "int METODOSCALIBRACAO::calibracaoGeometrica (MatrixXf & data, Matrix3f & sF, Vector3f & bias, float moduloCampo)\fC [inline]\fP"
Metodo geometrico para calibracao de magnetometros 
.PP
\fBParâmetros\fP
.RS 4
\fIdata\fP <Matrix com N linha e 3 colunas contendo os dados de amostra para a calibracao> [Matrix de scala] sF Matrix 3x3 com diagonal contendo os fatores de escalas 
.br
\fIbias\fP Vector 3x1 with the bias - ellipsoid center 
.br
\fImoduloCampo\fP values in uT of earth field 
.br
\fIsF\fP Matriz com fatores de escala na diagonal 
.br
\fIbias\fP vetor com o centro da elipsoide 
.RE
.PP
\fBRetorna\fP
.RS 4
1 para sucesso e -1 para falha 
.RE
.PP
\fBObservação\fP
.RS 4
The method fitting an ellipsoid with least squares method\&. The compensated measures M_c are obtained with the mensures M proceeding as follows: M_c = sF (M - bias) The method needs a full rotations for a good performance 
.RE
.PP

.PP
Definição na linha 44 do arquivo METODOSCALIBRACAO\&.h\&.
.PP
.nf
45                                               {
46 
47     // data eh uma matrix com N x 3, sendo N o numero de medidas coletadas
48     if (data\&.rows() == 3) {
49       data\&.transposeInPlace();
50     }
51     sF = Matrix3f::Identity();
52     bias = Vector3f::Zero();
53     int N = data\&.rows();
54     MatrixXf H = MatrixXf::Ones(N, 6);
55     VectorXf w(N), X(6), tmp(3);
56     H\&.col(0) = data\&.col(0);
57     H\&.col(1) = data\&.col(1);
58     H\&.col(2) = data\&.col(2);
59     H\&.col(3) = -data\&.col(1)\&.array()\&.pow(2)\&.matrix();
60     H\&.col(4) = -data\&.col(2)\&.array()\&.pow(2)\&.matrix();
61     w = data\&.col(0)\&.array()\&.pow(2)\&.matrix();
62     data\&.resize(0, 0); // libera memoria
63     // X = (H\&.transpose() * H)\&.inverse() * H\&.transpose() * w;
64     X = H\&.fullPivHouseholderQr()\&.solve(w);
65     H\&.resize(0, 0); // libera memoria
66     bias(0) = X(0) / 2\&.0;
67     bias(1) = X(1) / (2\&.0 * X(3));
68     bias(2) = X(2) / (2\&.0 * X(4));
69     tmp(0) = (X(5) + bias(0) * bias(0) + X(3) * bias(1) * bias(1) +
70               X(4) * bias(2) * bias(2)) /
71              (moduloCampo * moduloCampo);
72     tmp(1) = tmp(0) / X(3);
73     tmp(2) = tmp(0) / X(4);
74     sF(0, 0) = 1\&.0 / sqrt(tmp(0));
75     sF(1, 1) = 1\&.0 / sqrt(tmp(1));
76     sF(2, 2) = 1\&.0 / sqrt(tmp(2));
77 // checa se ha numero INFINITOS ou INVALIDOS retornoando -2
78 // quando encontra numeros NaN e -1 para numeros insfinitos
79 #ifndef __GNUC__
80     for (int i = 0; i < 3; i++) {
81       for (size_t j = 0; j < 3; j++) {
82         if (isnan(sF(i, j)) || isinf(sF(i, j))) {
83           return -2;
84         }
85       }
86       if (isnan(bias(i)) || isinf(bias(i))) {
87         return -1;
88       }
89     }
90 #endif
91     return 1;
92   }
.fi
.PP
Referencias data\&.
.PP
Referenciado(a) por IMU::calibracaoMagnetometro()\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
