.TH "src/main.cpp" 3 "Segunda, 25 de Outubro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/main.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'Controle\&.h'\fP
.br
\fC#include 'EKF\&.h'\fP
.br
\fC#include 'GRUPO_QUAT\&.h'\fP
.br
\fC#include 'IBusBM\&.h'\fP
.br
\fC#include 'Motores\&.h'\fP
.br
\fC#include 'PARAMETROS\&.h'\fP
.br
\fC#include 'TELEMETRIA\&.h'\fP
.br
\fC#include <Arduino\&.h>\fP
.br
\fC#include <eigen3/Eigen/Dense>\fP
.br
\fC#include 'COMMON\&.h'\fP
.br
\fC#include <iostream>\fP
.br

.SS "Definições e Macros"

.in +1c
.ti -1c
.RI "#define \fBDEBUG_MAIN\fP"
.br
.ti -1c
.RI "#define \fBPM\fP(X)   std::cout << #X << ':\\n' << X << '\\n'"
.br
.ti -1c
.RI "#define \fBCALIBRATION_OF_MAGNETOMETER_GYROSCOPE\fP"
.br
.in -1c
.SS "Funções"

.in +1c
.ti -1c
.RI "void \fBxTaskLoopFilter\fP (void *)"
.br
.ti -1c
.RI "void \fBxTaskSetupFiltro\fP (void *pvParameters)"
.br
.ti -1c
.RI "void \fBemergencyMethods\fP (void *pv)"
.br
.RI "Task de Procedimentos emergenciais\&. "
.ti -1c
.RI "void \fBxTaskContol\fP (void *pv)"
.br
.ti -1c
.RI "void \fBsetup\fP ()"
.br
.ti -1c
.RI "void \fBloop\fP ()"
.br
.in -1c
.SS "Variáveis"

.in +1c
.ti -1c
.RI "\fBIBusBM\fP \fBiBus\fP"
.br
.ti -1c
.RI "Vector3f * \fBeulerTarget\fP"
.br
.ti -1c
.RI "Vector3f * \fBra\fP"
.br
.ti -1c
.RI "Vector3f * \fBwa\fP"
.br
.ti -1c
.RI "Vector3f * \fBrI\fP"
.br
.ti -1c
.RI "Vector3f \fBqa\fP"
.br
.ti -1c
.RI "Vector4f * \fBmoments\fP"
.br
.ti -1c
.RI "Vector4i * \fBcomandosDigitais\fP"
.br
.ti -1c
.RI "\fBTELEMETRIA\fP \fBtel\fP"
.br
.ti -1c
.RI "TaskHandle_t \fBxHandleSetupFilter\fP = NULL"
.br
.ti -1c
.RI "TaskHandle_t \fBxHandleLoopFilter\fP = NULL"
.br
.ti -1c
.RI "TaskHandle_t \fBxHandleControl\fP = NULL"
.br
.ti -1c
.RI "TaskHandle_t \fBxHandleEmergency\fP = NULL"
.br
.in -1c
.SH "Descrição detalhada"
.PP 

.PP
\fBAutor\fP
.RS 4
: Roney Silva (roney) 
.RE
.PP
\fBData\fP
.RS 4
: 16-Aug-2021 Email: roneyddasilva@gmail.com Project: quadrirrotorUFABC
.RE
.PP
Last modified by: roney Last modified time: 31-Aug-2021 
.PP
Definição no arquivo \fBmain\&.cpp\fP\&.
.SH "Definições e macros"
.PP 
.SS "#define CALIBRATION_OF_MAGNETOMETER_GYROSCOPE"

.PP
Definição na linha 26 do arquivo main\&.cpp\&.
.SS "#define DEBUG_MAIN"

.PP
Definição na linha 20 do arquivo main\&.cpp\&.
.SS "#define PM(X)   std::cout << #X << ':\\n' << X << '\\n'"

.PP
Definição na linha 23 do arquivo main\&.cpp\&.
.SH "Funções"
.PP 
.SS "void emergencyMethods (void * pv)"

.PP
Task de Procedimentos emergenciais\&. 
.PP
Definição na linha 114 do arquivo main\&.cpp\&.
.PP
.nf
114                                 {
115   tel\&.enviaMensagem((char *)"emergencyMethods() Ativada");
116   vTaskSuspend(xHandleControl);
117   turnOnLed();
118   // pausa a task de controle
119   while (iBus\&.remoteControl\&.emergency > 1500) {
120     iBus\&.loop();
121     vTaskDelay(100);
122   }
123   turnOffLed();
124   vTaskResume(xHandleControl);
125   tel\&.enviaMensagem((char *)"emergencyMethods() Desativada");
126   vTaskDelete(NULL);
127 }
.fi
.PP
Referencias IBusBM::ControlUnion::emergency, TELEMETRIA::enviaMensagem(), iBus, IBusBM::loop(), IBusBM::remoteControl, tel, turnOffLed(), turnOnLed() e xHandleControl\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "void loop ()"

.PP
Definição na linha 237 do arquivo main\&.cpp\&.
.PP
.nf
237             {
238 #ifdef TEST_IMU
239   filtro\&.updateOfMeasurements();
240   PM(filtro\&.gyro\&.transpose());
241   PM(filtro\&.accel\&.transpose());
242   PM(filtro\&.mag\&.transpose());
243   delay(500);
244 #endif
245 }
.fi
.PP
Referencias ekf::EKF::accel, ekf::EKF::gyro, ekf::EKF::mag e PM\&.
.SS "void setup ()"

.PP
Definição na linha 214 do arquivo main\&.cpp\&.
.PP
.nf
214              {
215   pinMode(onboard_led, OUTPUT);
216 
217 #ifndef TEST_IMU
218   tel\&.begin();
219   iBus\&.begin(Serial2, IBUSBM_NOTIMER, pin_rx_controle);
220   iBus\&.loop();
221   while (iBus\&.remoteControl\&.emergency < 1000) {
222     tel\&.enviaMensagem((char *)"Cont Remoto com problema");
223     vTaskDelay(250);
224     iBus\&.loop();
225   }
226   tel\&.enviaMensagem((char *)"Controle ok");
227   tel\&.enviaMensagem((char *)"Criando Task xTaskSetupFiltro ");
228   xTaskCreatePinnedToCore(xTaskSetupFiltro, "SetupFiltro", 25000, NULL, 0,
229                           &xHandleSetupFilter, 0);
230   xTaskCreatePinnedToCore(xTaskContol, "Control", 20000, NULL, 2,
231                           &xHandleControl, 1);
232 #else
233   filtro\&.begin(float(dtTelemetry) * 1e-3);
234 #endif
235 }
.fi
.PP
Referencias TELEMETRIA::begin(), ekf::EKF::begin(), IBusBM::begin(), dtTelemetry, IBusBM::ControlUnion::emergency, TELEMETRIA::enviaMensagem(), iBus, IBUSBM_NOTIMER, IBusBM::loop(), onboard_led, pin_rx_controle, IBusBM::remoteControl, tel, xHandleControl, xHandleSetupFilter, xTaskContol() e xTaskSetupFiltro()\&.
.SS "void xTaskContol (void * pv)"

.PP
Definição na linha 128 do arquivo main\&.cpp\&.
.PP
.nf
128                            {
129   Controle ctrl(dtControle * 1e-3);
130   MOTOR_PINS mp;
131   eulerTarget = &ctrl\&.eulerTarget;
132   wa = &ctrl\&.wa;
133   ra = &ctrl\&.r;
134   moments = &ctrl\&.u;
135   comandosDigitais = &ctrl\&.motorCommands;
136 #ifdef INTEGRAL_CONTROL
137   rI = &ctrl\&.rI;
138 #else
139   rI = &ctrl\&.drone->p;
140 #endif
141   TickType_t xLastDtControl = 0;
142   // Instancia dos motores
143   Motores motor1(mp\&.motor_1, 0);
144   Motores motor2(mp\&.motor_2, 1);
145   Motores motor3(mp\&.motor_3, 2);
146   Motores motor4(mp\&.motor_4, 3);
147   tel\&.enviaMensagem((char *)"TaskControl \&.\&. esperando filtro");
148   while (filtro\&.status != READY) {
149     iBus\&.loop();
150     vTaskDelay(pdMS_TO_TICKS(1000));
151   }
152   tel\&.enviaMensagem((char *)"Filtro ok");
153   iBus\&.loop();
154   statusClass\&.ctrlStatus = READY;
155   ctrl\&.r = Vector3f::Zero();
156 
157   for (;;) {
158     // atualiza estados da classe Drone dada os valores estimado no EKF
159     iBus\&.loop();
160     // if (ibus\&.readChannel(4) > 1500) {
161     if (iBus\&.remoteControl\&.emergency < 1500) {
162       /*Para tentar obter os corretos valores de */
163 
164       ctrl\&.r(0) = ((float)(iBus\&.remoteControl\&.dX - 1500)) / 500\&.f;
165       ctrl\&.r(1) = ((float)(iBus\&.remoteControl\&.dY - 1500)) / 500\&.f;
166       ctrl\&.r(2) = ((float)(iBus\&.remoteControl\&.dZ - 1500)) / 500\&.f;
167       // Limita o máximo que o commando envia para o cotrole\&.
168       // ctrl\&.maximalDigitalCommand = 7\&.7 *
169       // ibus\&.remoteControl\&.throttle_limitation;
170 
171       tel\&.gainsTunning[1] =
172           9\&.999999 * ((float)iBus\&.remoteControl\&.adjustQuat - 1000\&.0f) + 0\&.001f;
173       tel\&.gainsTunning[2] =
174           9\&.999999 * ((float)iBus\&.remoteControl\&.adjustQrAngular - 1000\&.0f) +
175           0\&.001f;
176 
177       ctrl\&.Qr\&.topLeftCorner(3, 3) = Matrix3f::Identity() * tel\&.gainsTunning[1];
178       ctrl\&.Qr\&.bottomRightCorner(3, 3) =
179           Matrix3f::Identity() * tel\&.gainsTunning[2];
180       tel\&.gainsTunning[0] = ctrl\&.ut[2];
181       tel\&.enviaTunningGains();
182       ctrl\&.diffPsi = ((float)(iBus\&.remoteControl\&.dPsi - 1500)) / 500\&.f;
183       /* Atualiza estados da Classe Drone\&. Estes mesmos estados são utilizadas
184        * pela classe Controle para calcular as rotações dos motores\&.*/
185       ctrl\&.drone->p = filtro\&.rNED;
186       ctrl\&.drone->v = filtro\&.drNED;
187       ctrl\&.drone->q = filtro\&.q;
188       ctrl\&.drone->w = filtro\&.gyro;
189       qa = ctrl\&.qa\&.block(1, ctrl\&.index_alt, 3, 1);
190 
191       // adiciona as rotacoes
192       ctrl\&.controlLoop();
193       motor1\&.set_vel_mot(ctrl\&.motorCommands(0));
194       motor2\&.set_vel_mot(ctrl\&.motorCommands(1));
195       motor3\&.set_vel_mot(ctrl\&.motorCommands(2));
196       motor4\&.set_vel_mot(ctrl\&.motorCommands(3));
197 
198     } else {
199       // para os motores
200       motor1\&.set_vel_mot(ctrl\&.minimalDigitalCommand);
201       motor2\&.set_vel_mot(ctrl\&.minimalDigitalCommand);
202       motor3\&.set_vel_mot(ctrl\&.minimalDigitalCommand);
203       motor4\&.set_vel_mot(ctrl\&.minimalDigitalCommand);
204       tel\&.enviaMensagem((char *)"Condicao de paradada emergencyMethods()");
205       xTaskCreatePinnedToCore(emergencyMethods, "emergencyMethods", 2000, NULL,
206                               5, NULL, 1);
207     }
208 
209     vTaskDelayUntil(&xLastDtControl, xdtControle);
210   }
211 }
.fi
.PP
Referencias IBusBM::ControlUnion::adjustQrAngular, IBusBM::ControlUnion::adjustQuat, comandosDigitais, Controle::controlLoop(), Controle::diffPsi, IBusBM::ControlUnion::dPsi, ekf::EKF::drNED, Controle::drone, dtControle, IBusBM::ControlUnion::dX, IBusBM::ControlUnion::dY, IBusBM::ControlUnion::dZ, IBusBM::ControlUnion::emergency, emergencyMethods(), TELEMETRIA::enviaMensagem(), TELEMETRIA::enviaTunningGains(), Controle::eulerTarget, eulerTarget, TELEMETRIA::gainsTunning, ekf::EKF::gyro, iBus, Controle::index_alt, IBusBM::loop(), Controle::minimalDigitalCommand, moments, MOTOR_PINS::motor_1, MOTOR_PINS::motor_2, MOTOR_PINS::motor_3, MOTOR_PINS::motor_4, Controle::motorCommands, Drone::p, Drone::q, ekf::EKF::q, Controle::qa, qa, Controle::Qr, Controle::r, ra, ekf::READY, IBusBM::remoteControl, Controle::rI, rI, ekf::EKF::rNED, Motores::set_vel_mot(), ekf::EKF::status, tel, Controle::u, Controle::ut, Drone::v, Drone::w, Controle::wa, wa e xdtControle\&.
.PP
Referenciado(a) por setup()\&.
.SS "void xTaskLoopFilter (void *)"

.PP
Definição na linha 51 do arquivo main\&.cpp\&.
.PP
.nf
51                              {
52   tel\&.enviaMensagem((char *)"xTaskLoopFilter Criada");
53   TickType_t xLastDtTelemetry = 0;
54   const uint8_t size_data_to_send = 2 * (3 + 3 + 3 + 3);
55   Vector<float, size_data_to_send + 1> dataSerial;
56   statusClass\&.filtroStatus = filtro\&.status;
57   tel\&.enviaMensagem((char *)"Esperando a classe controle\&.\&.\&.");
58   while (statusClass\&.ctrlStatus != READY) {
59     vTaskDelay(1000);
60   }
61   tel\&.enviaMensagem((char *)"Contr\&.OK\&. estimador Rodando");
62 
63   for (;;) {
64     filtro\&.loopEKF();
65     quaternion2Euler(filtro\&.euler, filtro\&.q);
66 // 4 + 3+3+1+6
67 #if 0
68     tel\&.imu\&.dadosEigen <<         //
69                                   // /*0:3*/ RAD_TO_DEG * filtro\&.euler,   //
70         /*0:3*/ filtro\&.q\&.tail(3), //
71         /*3:6*/ filtro\&.gyro,      //
72         /*6:9*/ filtro\&.drNED,     //
73         /*9:12  filtro\&.rNED, */   //
74                                   // /*9:12*/ RAD_TO_DEG * (*eulerTarget),   //
75         /*9:12*/ qa,              //
76         /*12:15*/ *wa,            //
77         /*15:18*/ *ra,            //
78         /*  *rI*/                 //;
79         /*18:21*/ (*moments),
80         /*22:25*/ (*comandosDigitais)\&.cast<float>();
81     // tel\&.envia(size_data_to_send, dataSerial);
82     tel\&.envia();
83 #endif
84     vTaskDelayUntil(&xLastDtTelemetry, xdtTelemetry);
85   }
86 }
.fi
.PP
Referencias TELEMETRIA::IMU_DATA::dadosEigen, ekf::EKF::drNED, TELEMETRIA::envia(), TELEMETRIA::enviaMensagem(), ekf::EKF::euler, ekf::EKF::gyro, TELEMETRIA::imu, ekf::EKF::loopEKF(), ekf::EKF::q, qa, ekf::quaternion2Euler(), ra, ekf::READY, ekf::EKF::status, tel, wa e xdtTelemetry\&.
.PP
Referenciado(a) por xTaskSetupFiltro()\&.
.SS "void xTaskSetupFiltro (void * pvParameters)"

.PP
Definição na linha 87 do arquivo main\&.cpp\&.
.PP
.nf
87                                           {
88   tel\&.enviaMensagem((char *)"Dentro da xTaskSetupFiltro");
89   filtro\&.begin(float(dtTelemetry) * 1e-3);
90   tel\&.enviaMensagem((char *)"filtro\&.begin() ok");
91 #ifdef CALIBRATION_OF_MAGNETOMETER_GYROSCOPE
92   tel\&.enviaMensagem((char *)"Dentro da Calibracao");
93   iBus\&.loop();
94   printf(" valor da calibracao %d\n", iBus\&.remoteControl\&.calibration);
95   if (iBus\&.remoteControl\&.calibration > 1500) {
96     tel\&.enviaMensagem((char *)"Ent\&. no método de Calibracao");
97     filtro\&.calibrationMethods();
98     while (iBus\&.remoteControl\&.calibration > 1500) {
99       iBus\&.loop();
100       tel\&.enviaMensagem((char *)"Cal\&. OK\&. Turn of swb");
101       vTaskDelay(500);
102     }
103   }
104 #endif
105   xTaskCreate(xTaskLoopFilter, "FilterLoop", 15000, NULL, 0,
106               &xHandleLoopFilter);
107   tel\&.enviaMensagem((char *)"xTaskLoopFiltro");
108   vTaskDelete(NULL);
109 }
.fi
.PP
Referencias ekf::EKF::begin(), IBusBM::ControlUnion::calibration, dtTelemetry, TELEMETRIA::enviaMensagem(), iBus, IBusBM::loop(), IBusBM::remoteControl, tel, xHandleLoopFilter e xTaskLoopFilter()\&.
.PP
Referenciado(a) por setup()\&.
.SH "Variáveis"
.PP 
.SS "Vector4i* comandosDigitais"

.PP
Definição na linha 33 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "Vector3f* eulerTarget"

.PP
Definição na linha 30 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "\fBIBusBM\fP iBus"

.PP
Definição na linha 28 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por emergencyMethods(), setup(), xTaskContol() e xTaskSetupFiltro()\&.
.SS "Vector4f* moments"

.PP
Definição na linha 32 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "Vector3f qa"

.PP
Definição na linha 30 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol() e xTaskLoopFilter()\&.
.SS "Vector3f * ra"

.PP
Definição na linha 30 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol() e xTaskLoopFilter()\&.
.SS "Vector3f * rI"

.PP
Definição na linha 30 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "\fBTELEMETRIA\fP tel"

.PP
Definição na linha 35 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por emergencyMethods(), setup(), xTaskContol(), xTaskLoopFilter() e xTaskSetupFiltro()\&.
.SS "Vector3f * wa"

.PP
Definição na linha 30 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskContol() e xTaskLoopFilter()\&.
.SS "TaskHandle_t xHandleControl = NULL"

.PP
Definição na linha 48 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por emergencyMethods() e setup()\&.
.SS "TaskHandle_t xHandleEmergency = NULL"

.PP
Definição na linha 49 do arquivo main\&.cpp\&.
.SS "TaskHandle_t xHandleLoopFilter = NULL"

.PP
Definição na linha 47 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por xTaskSetupFiltro()\&.
.SS "TaskHandle_t xHandleSetupFilter = NULL"

.PP
Definição na linha 46 do arquivo main\&.cpp\&.
.PP
Referenciado(a) por setup()\&.
.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
