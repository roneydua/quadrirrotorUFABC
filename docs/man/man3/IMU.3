.TH "IMU" 3 "Sexta, 17 de Setembro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IMU
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IMU\&.h>\fP
.SS "Tipos Públicos"

.in +1c
.ti -1c
.RI "enum \fBGyroRange\fP { \fBGYRO_RANGE_250DPS\fP, \fBGYRO_RANGE_500DPS\fP, \fBGYRO_RANGE_1000DPS\fP, \fBGYRO_RANGE_2000DPS\fP }"
.br
.ti -1c
.RI "enum \fBAccelRange\fP { \fBACCEL_RANGE_2G\fP, \fBACCEL_RANGE_4G\fP, \fBACCEL_RANGE_8G\fP, \fBACCEL_RANGE_16G\fP }"
.br
.ti -1c
.RI "enum \fBDlpfBandwidth\fP { \fBDLPF_BANDWIDTH_184HZ\fP, \fBDLPF_BANDWIDTH_92HZ\fP, \fBDLPF_BANDWIDTH_41HZ\fP, \fBDLPF_BANDWIDTH_20HZ\fP, \fBDLPF_BANDWIDTH_10HZ\fP, \fBDLPF_BANDWIDTH_5HZ\fP }"
.br
.ti -1c
.RI "enum \fBLpAccelOdr\fP { \fBLP_ACCEL_ODR_0_24HZ\fP = 0, \fBLP_ACCEL_ODR_0_49HZ\fP = 1, \fBLP_ACCEL_ODR_0_98HZ\fP = 2, \fBLP_ACCEL_ODR_1_95HZ\fP = 3, \fBLP_ACCEL_ODR_3_91HZ\fP = 4, \fBLP_ACCEL_ODR_7_81HZ\fP = 5, \fBLP_ACCEL_ODR_15_63HZ\fP = 6, \fBLP_ACCEL_ODR_31_25HZ\fP = 7, \fBLP_ACCEL_ODR_62_50HZ\fP = 8, \fBLP_ACCEL_ODR_125HZ\fP = 9, \fBLP_ACCEL_ODR_250HZ\fP = 10, \fBLP_ACCEL_ODR_500HZ\fP = 11 }"
.br
.in -1c
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "\fBIMU\fP (TwoWire &bus, uint8_t address)"
.br
.ti -1c
.RI "int \fBbegin\fP (Vector3f &acel, Vector3f &gyro, Vector3f &mag)"
.br
.ti -1c
.RI "int \fBreadSensor\fP ()"
.br
.ti -1c
.RI "int \fBsetDlpfBandwidth\fP (\fBDlpfBandwidth\fP bandwidth)"
.br
.ti -1c
.RI "int \fBsetGyroRange\fP (\fBGyroRange\fP range)"
.br
.ti -1c
.RI "int \fBsetAccelRange\fP (\fBAccelRange\fP range)"
.br
.ti -1c
.RI "void \fBcalibraGyro\fP (int N=100)"
.br
.ti -1c
.RI "int \fBcalibracaoMagnetometro\fP (float moduloCampo)"
.br
.in -1c
.SS "Campos de Dados"

.in +1c
.ti -1c
.RI "Vector3f * \fB_acel\fP"
.br
.ti -1c
.RI "Vector3f * \fB_gyro\fP"
.br
.ti -1c
.RI "Vector3f * \fB_mag\fP"
.br
.ti -1c
.RI "Vector3f \fBmagTemp\fP"
.br
.ti -1c
.RI "float \fB_t\fP"
.br
.ti -1c
.RI "const Matrix3f \fBsFAccel\fP"
.br
.ti -1c
.RI "Vector3f \fB_biasAccel\fP {\-0\&.37238f, \-0\&.109074f, 0\&.121389f}"
.br
.ti -1c
.RI "Vector3f \fB_biasGyro\fP = Vector3f::Zero()"
.br
.ti -1c
.RI "Vector3f \fB_biasMag\fP = Vector3f::Zero()"
.br
.ti -1c
.RI "Matrix3f \fB_sM\fP = Matrix3f::Identity()"
.br
.ti -1c
.RI "TwoWire * \fB_i2c\fP"
.br
.in -1c
.SS "Membros Protegidos"

.in +1c
.ti -1c
.RI "int \fBwriteRegister\fP (uint8_t subAddress, uint8_t \fBdata\fP)"
.br
.ti -1c
.RI "int \fBreadRegisters\fP (uint8_t subAddress, uint8_t count, uint8_t *dest)"
.br
.ti -1c
.RI "int \fBwriteAK8963Register\fP (uint8_t subAddress, uint8_t \fBdata\fP)"
.br
.ti -1c
.RI "int \fBwhoAmI\fP ()"
.br
.ti -1c
.RI "int \fBwhoAmIAK8963\fP ()"
.br
.ti -1c
.RI "int \fBreadAK8963Registers\fP (uint8_t subAddress, uint8_t count, uint8_t *dest)"
.br
.in -1c
.SS "Atributos Protegidos"

.in +1c
.ti -1c
.RI "uint8_t \fB_buffer\fP [21]"
.br
.ti -1c
.RI "int16_t \fB_axcounts\fP"
.br
.ti -1c
.RI "int16_t \fB_aycounts\fP"
.br
.ti -1c
.RI "int16_t \fB_azcounts\fP"
.br
.ti -1c
.RI "int16_t \fB_gxcounts\fP"
.br
.ti -1c
.RI "int16_t \fB_gycounts\fP"
.br
.ti -1c
.RI "int16_t \fB_gzcounts\fP"
.br
.ti -1c
.RI "int16_t \fB_hxcounts\fP"
.br
.ti -1c
.RI "int16_t \fB_hycounts\fP"
.br
.ti -1c
.RI "int16_t \fB_hzcounts\fP"
.br
.ti -1c
.RI "int16_t \fB_tcounts\fP"
.br
.ti -1c
.RI "uint8_t \fB_address\fP"
.br
.ti -1c
.RI "size_t \fB_numBytes\fP"
.br
.RI "numero de bytes para leitura funcao readRegisters "
.ti -1c
.RI "const uint32_t \fB_i2cRate\fP = 400000"
.br
.ti -1c
.RI "int \fB_status\fP"
.br
.ti -1c
.RI "const float \fBgG\fP = 9\&.786171951281709f"
.br
.ti -1c
.RI "float \fB_accelScale\fP"
.br
.ti -1c
.RI "float \fB_gyroScale\fP"
.br
.ti -1c
.RI "float \fB_magScaleX\fP"
.br
.ti -1c
.RI "float \fB_magScaleY\fP"
.br
.ti -1c
.RI "float \fB_magScaleZ\fP"
.br
.ti -1c
.RI "\fBAccelRange\fP \fB_accelRange\fP"
.br
.ti -1c
.RI "\fBGyroRange\fP \fB_gyroRange\fP"
.br
.ti -1c
.RI "\fBDlpfBandwidth\fP \fB_bandwidth\fP"
.br
.ti -1c
.RI "uint8_t \fB_srd\fP"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_OUT\fP = 0x3B"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_OUT\fP = 0x43"
.br
.ti -1c
.RI "const uint8_t \fBTEMP_OUT\fP = 0x41"
.br
.ti -1c
.RI "const uint8_t \fBEXT_SENS_DATA_00\fP = 0x49"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_CONFIG\fP = 0x1C"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_FS_SEL_2G\fP = 0x00"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_FS_SEL_4G\fP = 0x08"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_FS_SEL_8G\fP = 0x10"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_FS_SEL_16G\fP = 0x18"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_CONFIG\fP = 0x1B"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_FS_SEL_250DPS\fP = 0x00"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_FS_SEL_500DPS\fP = 0x08"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_FS_SEL_1000DPS\fP = 0x10"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_FS_SEL_2000DPS\fP = 0x18"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_CONFIG2\fP = 0x1D"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_DLPF_184\fP = 0x01"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_DLPF_92\fP = 0x02"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_DLPF_41\fP = 0x03"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_DLPF_20\fP = 0x04"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_DLPF_10\fP = 0x05"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_DLPF_5\fP = 0x06"
.br
.ti -1c
.RI "const uint8_t \fBCONFIG\fP = 0x1A"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_DLPF_184\fP = 0x01"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_DLPF_92\fP = 0x02"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_DLPF_41\fP = 0x03"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_DLPF_20\fP = 0x04"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_DLPF_10\fP = 0x05"
.br
.ti -1c
.RI "const uint8_t \fBGYRO_DLPF_5\fP = 0x06"
.br
.ti -1c
.RI "const uint8_t \fBSMPDIV\fP = 0x19"
.br
.ti -1c
.RI "const uint8_t \fBINT_PIN_CFG\fP = 0x37"
.br
.ti -1c
.RI "const uint8_t \fBINT_ENABLE\fP = 0x38"
.br
.ti -1c
.RI "const uint8_t \fBINT_DISABLE\fP = 0x00"
.br
.ti -1c
.RI "const uint8_t \fBINT_PULSE_50US\fP = 0x00"
.br
.ti -1c
.RI "const uint8_t \fBINT_WOM_EN\fP = 0x40"
.br
.ti -1c
.RI "const uint8_t \fBINT_RAW_RDY_EN\fP = 0x01"
.br
.ti -1c
.RI "const uint8_t \fBPWR_MGMNT_1\fP = 0x6B"
.br
.ti -1c
.RI "const uint8_t \fBPWR_CYCLE\fP = 0x20"
.br
.ti -1c
.RI "const uint8_t \fBPWR_RESET\fP = 0x80"
.br
.ti -1c
.RI "const uint8_t \fBCLOCK_SEL_PLL\fP = 0x01"
.br
.ti -1c
.RI "const uint8_t \fBPWR_MGMNT_2\fP = 0x6C"
.br
.ti -1c
.RI "const uint8_t \fBSEN_ENABLE\fP = 0x00"
.br
.ti -1c
.RI "const uint8_t \fBDIS_GYRO\fP = 0x07"
.br
.ti -1c
.RI "const uint8_t \fBUSER_CTRL\fP = 0x6A"
.br
.ti -1c
.RI "const uint8_t \fBI2C_MST_EN\fP = 0x20"
.br
.ti -1c
.RI "const uint8_t \fBI2C_MST_CLK\fP = 0x0D"
.br
.ti -1c
.RI "const uint8_t \fBI2C_MST_CTRL\fP = 0x24"
.br
.ti -1c
.RI "const uint8_t \fBI2C_SLV0_ADDR\fP = 0x25"
.br
.ti -1c
.RI "const uint8_t \fBI2C_SLV0_REG\fP = 0x26"
.br
.ti -1c
.RI "const uint8_t \fBI2C_SLV0_DO\fP = 0x63"
.br
.ti -1c
.RI "const uint8_t \fBI2C_SLV0_CTRL\fP = 0x27"
.br
.ti -1c
.RI "const uint8_t \fBI2C_SLV0_EN\fP = 0x80"
.br
.ti -1c
.RI "const uint8_t \fBI2C_READ_FLAG\fP = 0x80"
.br
.ti -1c
.RI "const uint8_t \fBMOT_DETECT_CTRL\fP = 0x69"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_INTEL_EN\fP = 0x80"
.br
.ti -1c
.RI "const uint8_t \fBACCEL_INTEL_MODE\fP = 0x40"
.br
.ti -1c
.RI "const uint8_t \fBLP_ACCEL_ODR\fP = 0x1E"
.br
.ti -1c
.RI "const uint8_t \fBWOM_THR\fP = 0x1F"
.br
.ti -1c
.RI "const uint8_t \fBWHO_AM_I\fP = 0x75"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_I2C_ADDR\fP = 0x0C"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_HXL\fP = 0x03"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_CNTL1\fP = 0x0A"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_PWR_DOWN\fP = 0x00"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_CNT_MEAS1\fP = 0x12"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_CNT_MEAS2\fP = 0x16"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_FUSE_ROM\fP = 0x0F"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_CNTL2\fP = 0x0B"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_RESET\fP = 0x01"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_ASA\fP = 0x10"
.br
.ti -1c
.RI "const uint8_t \fBAK8963_WHO_AM_I\fP = 0x00"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 19 do arquivo IMU\&.h\&.
.SH "Enumerações"
.PP 
.SS "enum \fBIMU::AccelRange\fP"

.PP
\fBEnumeradores\fP
.in +1c
.TP
\fB\fIACCEL_RANGE_2G \fP\fP
.TP
\fB\fIACCEL_RANGE_4G \fP\fP
.TP
\fB\fIACCEL_RANGE_8G \fP\fP
.TP
\fB\fIACCEL_RANGE_16G \fP\fP
.PP
Definição na linha 27 do arquivo IMU\&.h\&.
.PP
.nf
27                   {
28     ACCEL_RANGE_2G,
29     ACCEL_RANGE_4G,
30     ACCEL_RANGE_8G,
31     ACCEL_RANGE_16G
32   };
.fi
.SS "enum \fBIMU::DlpfBandwidth\fP"

.PP
\fBEnumeradores\fP
.in +1c
.TP
\fB\fIDLPF_BANDWIDTH_184HZ \fP\fP
.TP
\fB\fIDLPF_BANDWIDTH_92HZ \fP\fP
.TP
\fB\fIDLPF_BANDWIDTH_41HZ \fP\fP
.TP
\fB\fIDLPF_BANDWIDTH_20HZ \fP\fP
.TP
\fB\fIDLPF_BANDWIDTH_10HZ \fP\fP
.TP
\fB\fIDLPF_BANDWIDTH_5HZ \fP\fP
.PP
Definição na linha 33 do arquivo IMU\&.h\&.
.PP
.nf
33                      {
34     DLPF_BANDWIDTH_184HZ,
35     DLPF_BANDWIDTH_92HZ,
36     DLPF_BANDWIDTH_41HZ,
37     DLPF_BANDWIDTH_20HZ,
38     DLPF_BANDWIDTH_10HZ,
39     DLPF_BANDWIDTH_5HZ
40   };
.fi
.SS "enum \fBIMU::GyroRange\fP"

.PP
\fBEnumeradores\fP
.in +1c
.TP
\fB\fIGYRO_RANGE_250DPS \fP\fP
.TP
\fB\fIGYRO_RANGE_500DPS \fP\fP
.TP
\fB\fIGYRO_RANGE_1000DPS \fP\fP
.TP
\fB\fIGYRO_RANGE_2000DPS \fP\fP
.PP
Definição na linha 21 do arquivo IMU\&.h\&.
.PP
.nf
21                  {
22     GYRO_RANGE_250DPS,
23     GYRO_RANGE_500DPS,
24     GYRO_RANGE_1000DPS,
25     GYRO_RANGE_2000DPS
26   };
.fi
.SS "enum \fBIMU::LpAccelOdr\fP"

.PP
\fBEnumeradores\fP
.in +1c
.TP
\fB\fILP_ACCEL_ODR_0_24HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_0_49HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_0_98HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_1_95HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_3_91HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_7_81HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_15_63HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_31_25HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_62_50HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_125HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_250HZ \fP\fP
.TP
\fB\fILP_ACCEL_ODR_500HZ \fP\fP
.PP
Definição na linha 41 do arquivo IMU\&.h\&.
.PP
.nf
41                   {
42     LP_ACCEL_ODR_0_24HZ = 0,
43     LP_ACCEL_ODR_0_49HZ = 1,
44     LP_ACCEL_ODR_0_98HZ = 2,
45     LP_ACCEL_ODR_1_95HZ = 3,
46     LP_ACCEL_ODR_3_91HZ = 4,
47     LP_ACCEL_ODR_7_81HZ = 5,
48     LP_ACCEL_ODR_15_63HZ = 6,
49     LP_ACCEL_ODR_31_25HZ = 7,
50     LP_ACCEL_ODR_62_50HZ = 8,
51     LP_ACCEL_ODR_125HZ = 9,
52     LP_ACCEL_ODR_250HZ = 10,
53     LP_ACCEL_ODR_500HZ = 11
54   };
.fi
.SH "Construtores e Destrutores"
.PP 
.SS "IMU::IMU (TwoWire & bus, uint8_t address)"
Construtor da classe \fBIMU\fP\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIbus\fP classe de comunicacao Wire\&. 
.br
\fIaddress\fP Endereço do imu\&. 
.RE
.PP

.PP
Definição na linha 17 do arquivo IMU\&.cpp\&.
.PP
.nf
17                                       {
18   _i2c = &bus;
19   _address = address;
20   Serial\&.println("Imu ok");
21 }
.fi
.PP
Referencias _address e _i2c\&.
.SH "Funções membros"
.PP 
.SS "int IMU::begin (Vector3f & acel, Vector3f & gyro, Vector3f & mag)"
Inicialização e configuração da unidade MARG\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIacel\fP Vetor de medidas do acelerômetro\&. 
.br
\fIgyro\fP Vetor de medidas do giroscópio\&. 
.br
\fImag\fP Vetor de medidas do Magnetômetro\&. 
.RE
.PP
\fBRetorna\fP
.RS 4
inteiro positivo para ok ou negativo para erros\&. 
.RE
.PP

.PP
Definição na linha 29 do arquivo IMU\&.cpp\&.
.PP
.nf
29                                                             {
30   _acel = &acel;
31   _gyro = &gyro;
32   _mag = &mag;
33   // para analise da calibracao
34   // inicializa a biblioteca Wire para comunicacao i2c
35   _i2c->begin(21, 22);
36 
37   // seta a frequencia de comunicacao I2c
38   // _i2c->setClock(_i2cRate);
39   // seleciona o "clock source" do giroscopio
40 
41   writeRegister(PWR_MGMNT_1, CLOCK_SEL_PLL);
42   // habilita o modo master i2c
43   writeRegister(USER_CTRL, I2C_MST_EN);
44   // configura a frequencia do I2c
45   writeRegister(I2C_MST_CTRL, I2C_MST_CLK);
46   // desliga o magnetometro
47   writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN);
48   // reseta a MPU9250
49   writeRegister(PWR_MGMNT_1, PWR_RESET);
50   delay(1);
51   // reset o magnetometro
52   writeAK8963Register(AK8963_CNTL2, AK8963_RESET);
53   // seleciona o "clock source" do giroscopio
54   writeRegister(PWR_MGMNT_1, CLOCK_SEL_PLL);
55   // habilita o acelerometro o giroscopio
56   writeRegister(PWR_MGMNT_2, SEN_ENABLE);
57   // selecionas as escalas de 16G e 2000DPS para acel e Giro como padrao
58   setAccelRange(ACCEL_RANGE_16G);
59   setGyroRange(GYRO_RANGE_1000DPS);
60   // atribui define a largura de banda como padrao
61   _bandwidth = DLPF_BANDWIDTH_5HZ;
62   setDlpfBandwidth(_bandwidth);
63   writeRegister(SMPDIV, 0x00);
64   _srd = 0;
65   // enable I2C master mode
66   if (writeRegister(USER_CTRL, I2C_MST_EN) < 0) {
67     return -12;
68   }
69   // set the I2C bus speed to 400 kHz
70   if (writeRegister(I2C_MST_CTRL, I2C_MST_CLK) < 0) {
71     return -13;
72   }
73   // check AK8963 WHO AM I register, expected value is 0x48 (decimal 72)
74   if (whoAmIAK8963() != 72) {
75     return -14;
76   }
77   /* get the magnetometer calibration */
78   // set AK8963 to Power Down
79   if (writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN) < 0) {
80     return -15;
81   }
82   delay(100); // long wait between AK8963 mode changes
83   // set AK8963 to FUSE ROM access
84   if (writeAK8963Register(AK8963_CNTL1, AK8963_FUSE_ROM) < 0) {
85     return -16;
86   }
87   delay(100);
88   // para detalhes ver manual AK8963 pag\&. 32  e pg\&. 29
89   readAK8963Registers(AK8963_ASA, 3, _buffer);
90   _magScaleX = ((((float)_buffer[0]) - 128\&.0) / (256\&.0) + 1\&.0) * 4912\&.0 /
91                32760\&.0; // micro Tesla
92   _magScaleY = ((((float)_buffer[1]) - 128\&.0) / (256\&.0) + 1\&.0) * 4912\&.0 /
93                32760\&.0; // micro Tesla
94   _magScaleZ = ((((float)_buffer[2]) - 128\&.0) / (256\&.0) + 1\&.0) * 4912\&.0 /
95                32760\&.0; // micro Tesla
96   // set AK8963 desligao magnetometro
97   if (writeAK8963Register(AK8963_CNTL1, AK8963_PWR_DOWN) < 0) {
98     return -17;
99   }
100   delay(100); // delay para aplicacao das configuracoes
101   // inicializa o magnetometro com resolucao de 16bit e 100Hz
102   if (writeAK8963Register(AK8963_CNTL1, AK8963_CNT_MEAS2) < 0) {
103     return -18;
104   }
105   delay(100); // delay para aplicacao das configuracoes
106   // select clock source to gyro
107   if (writeRegister(PWR_MGMNT_1, CLOCK_SEL_PLL) < 0) {
108     return -19;
109   }
110   // instruct the MPU9250 to get 7 bytes of data from the AK8963 at the sample
111   // rate
112   readAK8963Registers(AK8963_HXL, 7, _buffer);
113 
114   return 1;
115 }
.fi
.PP
Referencias _acel, _bandwidth, _buffer, _gyro, _i2c, _mag, _magScaleX, _magScaleY, _magScaleZ, _srd, ACCEL_RANGE_16G, AK8963_ASA, AK8963_CNT_MEAS2, AK8963_CNTL1, AK8963_CNTL2, AK8963_FUSE_ROM, AK8963_HXL, AK8963_PWR_DOWN, AK8963_RESET, CLOCK_SEL_PLL, DLPF_BANDWIDTH_5HZ, GYRO_RANGE_1000DPS, I2C_MST_CLK, I2C_MST_CTRL, I2C_MST_EN, PWR_MGMNT_1, PWR_MGMNT_2, PWR_RESET, readAK8963Registers(), SEN_ENABLE, setAccelRange(), setDlpfBandwidth(), setGyroRange(), SMPDIV, USER_CTRL, whoAmIAK8963(), writeAK8963Register() e writeRegister()\&.
.PP
Referenciado(a) por ekf::EKF::begin()\&.
.SS "int IMU::calibracaoMagnetometro (float moduloCampo)"

.PP
Definição na linha 458 do arquivo IMU\&.cpp\&.
.PP
.nf
458                                                  {
459 
460   // numero de medidas para armazenar dados
461   METODOSCALIBRACAO CAL; // instancia funcoes de calibracao
462   int N = 500;
463   MatrixXf medidas = MatrixXf::Zero(3, N);
464   // coleta N medidas
465   VectorXf temp(17);
466   for (int i = 0; i < N; i++) {
467     readSensor();
468     medidas\&.col(i) = magTemp;
469     delay(20);
470   }
471   return CAL\&.calibracaoGeometrica(medidas, _sM, _biasMag, moduloCampo);
472 }
.fi
.PP
Referencias _biasMag, _sM, METODOSCALIBRACAO::calibracaoGeometrica(), magTemp e readSensor()\&.
.SS "void IMU::calibraGyro (int N = \fC100\fP)"
Metódo de calibração do giroscópio\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIN\fP número de dados coletados para computodo da média
.RE
.PP
Compensa-se o erro sistemático eliminando calculando a médida de #N medidas\&. O valor compensando é dado por gyro_c = _gyroScale*(gyro_m - _biasGyro) 
.PP
Definição na linha 343 do arquivo IMU\&.cpp\&.
.PP
.nf
343                              {
344   Eigen::Vector3f _biasGyroTemp = Eigen::Vector3f::Zero();
345   // Eigen::Vector3f _biasAcelTemp = Eigen::Vector3f::Zero();
346   for (int i = 0; i < N; i++) {
347     readSensor();
348     _biasGyroTemp += *_gyro;
349     // _biasAcelTemp += *_acel;
350     delay(20);
351   }
352   // _biasGyro /= (float(N) * _gyroScale);
353   _biasGyro = _biasGyroTemp / float(N);
354   // _biasAcelTemp /= float(N);
355   // _biasAccel(0) = _biasAcelTemp(0);
356   // _biasAccel(1) = _biasAcelTemp(1);
357   // _biasAccel(2) = _biasAcelTemp(2) - gG;
358 }
.fi
.PP
Referencias _biasGyro, _gyro e readSensor()\&.
.SS "int IMU::readAK8963Registers (uint8_t subAddress, uint8_t count, uint8_t * dest)\fC [protected]\fP"

.PP
Definição na linha 360 do arquivo IMU\&.cpp\&.
.PP
.nf
360                                                                              {
361   writeRegister(I2C_SLV0_ADDR, AK8963_I2C_ADDR | I2C_READ_FLAG);
362   writeRegister(I2C_SLV0_REG, subAddress);
363   writeRegister(I2C_SLV0_CTRL, I2C_SLV0_EN | count);
364   // delay(1);
365   _status = readRegisters(EXT_SENS_DATA_00, count, _buffer);
366   return _status;
367 }
.fi
.PP
Referencias _buffer, _status, AK8963_I2C_ADDR, EXT_SENS_DATA_00, I2C_READ_FLAG, I2C_SLV0_ADDR, I2C_SLV0_CTRL, I2C_SLV0_EN, I2C_SLV0_REG, readRegisters() e writeRegister()\&.
.PP
Referenciado(a) por begin(), whoAmIAK8963() e writeAK8963Register()\&.
.SS "int IMU::readRegisters (uint8_t subAddress, uint8_t count, uint8_t * dest)\fC [protected]\fP"
Leitura dos registros da MARG 
.PP
\fBParâmetros\fP
.RS 4
\fIsubAddress\fP 
.br
\fIcount\fP 
.br
\fIdest\fP 
.RE
.PP
\fBRetorna\fP
.RS 4
positivo se ok, negativo para o contrário\&. 
.RE
.PP

.PP
Definição na linha 424 do arquivo IMU\&.cpp\&.
.PP
.nf
424                                                                        {
425   _i2c->beginTransmission(_address);
426   _i2c->write(subAddress);
427   _i2c->endTransmission(false);
428   _numBytes = _i2c->requestFrom(_address, count);
429   if (_numBytes == count) {
430     for (uint8_t i = 0; i < count; i++) {
431       dest[i] = _i2c->read();
432     }
433     return 1;
434   } else {
435     return -1;
436   }
437 }
.fi
.PP
Referencias _address, _i2c e _numBytes\&.
.PP
Referenciado(a) por readAK8963Registers(), readSensor(), whoAmI() e writeRegister()\&.
.SS "int IMU::readSensor ()"
Faz leitura da MARG\&. 
.PP
\fBRetorna\fP
.RS 4
Positivo se ok, negativo para ok contrário\&.
.RE
.PP
As variáveis \fB_acel\fP, \fB_gyro\fP e \fB_mag\fP são modificadas\&. 
.PP
Definição na linha 290 do arquivo IMU\&.cpp\&.
.PP
.nf
290                     {
291   //_useSPIHS = true; // use the high speed SPI for data readout
292   // grab the data from the MPU9250
293   if (readRegisters(ACCEL_OUT, 21, _buffer) < 0) {
294     return -1;
295   }
296   // combine into 16 bit values
297   _axcounts = (((int16_t)_buffer[0]) << 8) | _buffer[1];
298   _aycounts = (((int16_t)_buffer[2]) << 8) | _buffer[3];
299   _azcounts = (((int16_t)_buffer[4]) << 8) | _buffer[5];
300 
301   // _tcounts = (((int16_t)_buffer[6]) << 8) | _buffer[7];
302 
303   _gxcounts = (((int16_t)_buffer[8]) << 8) | _buffer[9];
304   _gycounts = (((int16_t)_buffer[10]) << 8) | _buffer[11];
305   _gzcounts = (((int16_t)_buffer[12]) << 8) | _buffer[13];
306 
307   _hxcounts = (((int16_t)_buffer[15]) << 8) | _buffer[14];
308   _hycounts = (((int16_t)_buffer[17]) << 8) | _buffer[16];
309   _hzcounts = (((int16_t)_buffer[19]) << 8) | _buffer[18];
310   /* corrige a direcao do eixo z  para -z e comuta o x com o y
311 esse procedimento eh fundamental para que os eixos do acelerometro e gyro seja
312 compartilhados como o magnetometro */
313   // *_acel << (float)(_aycounts - _biasAccel[0]),
314   //     (float)(_axcounts - _biasAccel[1]), (float)(_azcounts - _biasAccel[2]);
315   *_acel << (float)(_aycounts), (float)(_axcounts), (float)(_azcounts);
316   // *_acel *= _accelScale;
317   // *_acel -= _biasAccel;
318   *_acel = sFAccel * (*_acel) - _biasAccel;
319   *_gyro << -(float)_gycounts, -(float)_gxcounts, -(float)_gzcounts;
320   *_gyro *= _gyroScale;
321   *_gyro -= _biasGyro;
322   // *_mag << -(float)_hxcounts*_magScaleX, -(float)_hycounts*_magScaleX,
323   // (float)_hzcounts*_magScaleX;
324   // *_mag = _sM * (*_mag - _biasMag);
325   // para analise da calibracao
326   magTemp << -(float)_hxcounts * _magScaleX, -(float)_hycounts * _magScaleX,
327       -(float)_hzcounts * _magScaleX;
328   // *_mag = _sM * (magTemp - _biasMag);
329   *_mag = (magTemp - _biasMag);
330   /* @annotation retirado do manual de registros da mpu9250 pag\&.33*/
331   // TEMP_degC = ((TEMP_OUT – RoomTemp_Offset)/Temp_Sensitivity)+ 21degC
332   // RoomTemp_Offset = 21; Temp_Sensitivity = 333\&.87
333   // _t = (float)_tcounts / 333\&.87f - 20\&.937101267f;
334   return 1;
335 }
.fi
.PP
Referencias _acel, _axcounts, _aycounts, _azcounts, _biasAccel, _biasGyro, _biasMag, _buffer, _gxcounts, _gycounts, _gyro, _gyroScale, _gzcounts, _hxcounts, _hycounts, _hzcounts, _mag, _magScaleX, ACCEL_OUT, magTemp, readRegisters() e sFAccel\&.
.PP
Referenciado(a) por ekf::EKF::begin(), calibracaoMagnetometro() e calibraGyro()\&.
.SS "int IMU::setAccelRange (\fBAccelRange\fP range)"
Configura a sensibilidade de operação do acelerômetro\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIrange\fP de operação 
.RE
.PP
\fBRetorna\fP
.RS 4
positivo se ok, negativo se falhar\&. 
.RE
.PP

.PP
Definição na linha 121 do arquivo IMU\&.cpp\&.
.PP
.nf
121                                        {
122   switch (range) {
123   case ACCEL_RANGE_2G: {
124     // setting the accel range to 2G
125     if (writeRegister(ACCEL_CONFIG, ACCEL_FS_SEL_2G) < 0) {
126       return -1;
127     }
128     _accelScale = (gG * 2\&.0) / 32768\&.0; // setting the accel scale to 2G
129     break;
130   }
131   case ACCEL_RANGE_4G: {
132     // setting the accel range to 4G
133     if (writeRegister(ACCEL_CONFIG, ACCEL_FS_SEL_4G) < 0) {
134       return -1;
135     }
136     _accelScale = (gG * 4\&.0f) / 32768\&.0f; // setting the accel scale to 4G
137     break;
138   }
139   case ACCEL_RANGE_8G: {
140     // setting the accel range to 8G
141     if (writeRegister(ACCEL_CONFIG, ACCEL_FS_SEL_8G) < 0) {
142       return -1;
143     }
144     _accelScale = (gG * 8\&.0f) / 32768\&.0f; // setting the accel scale to 8G
145     break;
146   }
147   case ACCEL_RANGE_16G: {
148     // setting the accel range to 16G
149     if (writeRegister(ACCEL_CONFIG, ACCEL_FS_SEL_16G) < 0) {
150       return -1;
151     }
152     _accelScale = (gG * 16\&.0f) / 32768\&.0f; // setting the accel scale to 16G
153     break;
154   }
155   }
156   _accelRange = range;
157   return 1;
158 }
.fi
.PP
Referencias _accelRange, _accelScale, ACCEL_CONFIG, ACCEL_FS_SEL_16G, ACCEL_FS_SEL_2G, ACCEL_FS_SEL_4G, ACCEL_FS_SEL_8G, ACCEL_RANGE_16G, ACCEL_RANGE_2G, ACCEL_RANGE_4G, ACCEL_RANGE_8G, gG e writeRegister()\&.
.PP
Referenciado(a) por begin()\&.
.SS "int IMU::setDlpfBandwidth (\fBDlpfBandwidth\fP bandwidth)"
Configura a o filtro passa baixa do acelerômetro e do giroscópio\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIbandwidth\fP de operação 
.RE
.PP
\fBRetorna\fP
.RS 4
positivo se ok, negativo se falhar\&. 
.RE
.PP

.PP
Definição na linha 213 do arquivo IMU\&.cpp\&.
.PP
.nf
213                                                  {
214   switch (bandwidth) {
215   case DLPF_BANDWIDTH_184HZ: {
216     if (writeRegister(ACCEL_CONFIG2, ACCEL_DLPF_184) <
217         0) { // setting accel bandwidth to 184Hz
218       return -1;
219     }
220     if (writeRegister(CONFIG, GYRO_DLPF_184) <
221         0) { // setting gyro bandwidth to 184Hz
222       return -2;
223     }
224     break;
225   }
226   case DLPF_BANDWIDTH_92HZ: {
227     if (writeRegister(ACCEL_CONFIG2, ACCEL_DLPF_92) <
228         0) { // setting accel bandwidth to 92Hz
229       return -1;
230     }
231     if (writeRegister(CONFIG, GYRO_DLPF_92) <
232         0) { // setting gyro bandwidth to 92Hz
233       return -2;
234     }
235     break;
236   }
237   case DLPF_BANDWIDTH_41HZ: {
238     if (writeRegister(ACCEL_CONFIG2, ACCEL_DLPF_41) <
239         0) { // setting accel bandwidth to 41Hz
240       return -1;
241     }
242     if (writeRegister(CONFIG, GYRO_DLPF_41) <
243         0) { // setting gyro bandwidth to 41Hz
244       return -2;
245     }
246     break;
247   }
248   case DLPF_BANDWIDTH_20HZ: {
249     if (writeRegister(ACCEL_CONFIG2, ACCEL_DLPF_20) <
250         0) { // setting accel bandwidth to 20Hz
251       return -1;
252     }
253     if (writeRegister(CONFIG, GYRO_DLPF_20) <
254         0) { // setting gyro bandwidth to 20Hz
255       return -2;
256     }
257     break;
258   }
259   case DLPF_BANDWIDTH_10HZ: {
260     if (writeRegister(ACCEL_CONFIG2, ACCEL_DLPF_10) <
261         0) { // setting accel bandwidth to 10Hz
262       return -1;
263     }
264     if (writeRegister(CONFIG, GYRO_DLPF_10) <
265         0) { // setting gyro bandwidth to 10Hz
266       return -2;
267     }
268     break;
269   }
270   case DLPF_BANDWIDTH_5HZ: {
271     if (writeRegister(ACCEL_CONFIG2, ACCEL_DLPF_5) <
272         0) { // setting accel bandwidth to 5Hz
273       return -1;
274     }
275     if (writeRegister(CONFIG, GYRO_DLPF_5) <
276         0) { // setting gyro bandwidth to 5Hz
277       return -2;
278     }
279     break;
280   }
281   }
282   _bandwidth = bandwidth;
283   return 1;
284 }
.fi
.PP
Referencias _bandwidth, ACCEL_CONFIG2, ACCEL_DLPF_10, ACCEL_DLPF_184, ACCEL_DLPF_20, ACCEL_DLPF_41, ACCEL_DLPF_5, ACCEL_DLPF_92, CONFIG, DLPF_BANDWIDTH_10HZ, DLPF_BANDWIDTH_184HZ, DLPF_BANDWIDTH_20HZ, DLPF_BANDWIDTH_41HZ, DLPF_BANDWIDTH_5HZ, DLPF_BANDWIDTH_92HZ, GYRO_DLPF_10, GYRO_DLPF_184, GYRO_DLPF_20, GYRO_DLPF_41, GYRO_DLPF_5, GYRO_DLPF_92 e writeRegister()\&.
.PP
Referenciado(a) por begin()\&.
.SS "int IMU::setGyroRange (\fBGyroRange\fP range)"
Configura a sensibilidade de operação do giroscópio\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIrange\fP de operação 
.RE
.PP
\fBRetorna\fP
.RS 4
positivo se ok, negativo se falhar\&. 
.RE
.PP

.PP
Definição na linha 165 do arquivo IMU\&.cpp\&.
.PP
.nf
165                                      {
166   switch (range) {
167   case GYRO_RANGE_250DPS: {
168     // setting the gyro range to 250DPS
169     if (writeRegister(GYRO_CONFIG, GYRO_FS_SEL_250DPS) < 0) {
170       return -1;
171     }
172     _gyroScale =
173         250\&.0 / 32767\&.5 * DEG_TO_RAD; // setting the gyro scale to 250DPS
174     break;
175   }
176   case GYRO_RANGE_500DPS: {
177     // setting the gyro range to 500DPS
178     if (writeRegister(GYRO_CONFIG, GYRO_FS_SEL_500DPS) < 0) {
179       return -1;
180     }
181     _gyroScale =
182         500\&.0 / 32767\&.5 * DEG_TO_RAD; // setting the gyro scale to 500DPS
183     break;
184   }
185   case GYRO_RANGE_1000DPS: {
186     // setting the gyro range to 1000DPS
187     if (writeRegister(GYRO_CONFIG, GYRO_FS_SEL_1000DPS) < 0) {
188       return -1;
189     }
190     _gyroScale =
191         1000\&.0 / 32767\&.5 * DEG_TO_RAD; // setting the gyro scale to 1000DPS
192     break;
193   }
194   case GYRO_RANGE_2000DPS: {
195     // setting the gyro range to 2000DPS
196     if (writeRegister(GYRO_CONFIG, GYRO_FS_SEL_2000DPS) < 0) {
197       return -1;
198     }
199     _gyroScale =
200         2000\&.0 / 32767\&.5 * DEG_TO_RAD; // setting the gyro scale to 2000DPS
201     break;
202   }
203   }
204   _gyroRange = range;
205   return 1;
206 }
.fi
.PP
Referencias _gyroRange, _gyroScale, GYRO_CONFIG, GYRO_FS_SEL_1000DPS, GYRO_FS_SEL_2000DPS, GYRO_FS_SEL_250DPS, GYRO_FS_SEL_500DPS, GYRO_RANGE_1000DPS, GYRO_RANGE_2000DPS, GYRO_RANGE_250DPS, GYRO_RANGE_500DPS e writeRegister()\&.
.PP
Referenciado(a) por begin()\&.
.SS "int IMU::whoAmI ()\fC [protected]\fP"
Checa o registro de um dispositivo\&.
.PP
usado para o acelerômetro e giroscópio\&. 
.PP
Definição na linha 442 do arquivo IMU\&.cpp\&.
.PP
.nf
442                 {
443   readRegisters(WHO_AM_I, 1, _buffer);
444   return _buffer[0];
445 }
.fi
.PP
Referencias _buffer, readRegisters() e WHO_AM_I\&.
.SS "int IMU::whoAmIAK8963 ()\fC [protected]\fP"
Verifica se o Magnetômetro está ok\&. 
.PP
Definição na linha 449 do arquivo IMU\&.cpp\&.
.PP
.nf
449                       {
450   if (readAK8963Registers(AK8963_WHO_AM_I, 1, _buffer) < 0) {
451     Serial\&.println("Nao sei quem sou");
452     return -1;
453   }
454   // Serial\&.println("Endereco do magnetometro");
455   // Serial\&.print(_buffer[0]);
456   return _buffer[0];
457 }
.fi
.PP
Referencias _buffer, AK8963_WHO_AM_I e readAK8963Registers()\&.
.PP
Referenciado(a) por begin()\&.
.SS "int IMU::writeAK8963Register (uint8_t subAddress, uint8_t data)\fC [protected]\fP"

.PP
Definição na linha 368 do arquivo IMU\&.cpp\&.
.PP
.nf
368                                                              {
369   // set slave 0 to the AK8963 and set for write
370   if (writeRegister(I2C_SLV0_ADDR, AK8963_I2C_ADDR) < 0) {
371     return -1;
372   }
373   // set the register to the desired AK8963 sub address
374   if (writeRegister(I2C_SLV0_REG, subAddress) < 0) {
375     return -2;
376   }
377   // store the data for write
378   if (writeRegister(I2C_SLV0_DO, data) < 0) {
379     return -3;
380   }
381   // enable I2C and send 1 byte
382   if (writeRegister(I2C_SLV0_CTRL, I2C_SLV0_EN | (uint8_t)1) < 0) {
383     return -4;
384   }
385   // read the register and confirm
386   if (readAK8963Registers(subAddress, 1, _buffer) < 0) {
387     return -5;
388   }
389   if (_buffer[0] == data) {
390     return 1;
391   } else {
392     return -6;
393   }
394 }
.fi
.PP
Referencias _buffer, AK8963_I2C_ADDR, data, I2C_SLV0_ADDR, I2C_SLV0_CTRL, I2C_SLV0_DO, I2C_SLV0_EN, I2C_SLV0_REG, readAK8963Registers() e writeRegister()\&.
.PP
Referenciado(a) por begin()\&.
.SS "int IMU::writeRegister (uint8_t subAddress, uint8_t data)\fC [protected]\fP"
Escreve nos registros da Marg 
.PP
\fBParâmetros\fP
.RS 4
\fIsubAddress\fP 
.br
\fIdata\fP 
.RE
.PP
\fBRetorna\fP
.RS 4
.RE
.PP
Esada para ler os dados e configurar a MARG\&. 
.PP
Definição na linha 402 do arquivo IMU\&.cpp\&.
.PP
.nf
402                                                        {
403   _i2c->beginTransmission(_address); // open the device
404   _i2c->write(subAddress);           // write the register address
405   _i2c->write(data);                 // write the data
406   _i2c->endTransmission();
407   // delay(10);
408   /* read back the register */
409   readRegisters(subAddress, 1, _buffer);
410   /* check the read back register against the written register */
411   if (_buffer[0] == data) {
412     return 1;
413   } else {
414     return -1;
415   }
416 }
.fi
.PP
Referencias _address, _buffer, _i2c, data e readRegisters()\&.
.PP
Referenciado(a) por begin(), readAK8963Registers(), setAccelRange(), setDlpfBandwidth(), setGyroRange() e writeAK8963Register()\&.
.SH "Campos"
.PP 
.SS "\fBAccelRange\fP IMU::_accelRange\fC [protected]\fP"

.PP
Definição na linha 117 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "float IMU::_accelScale\fC [protected]\fP"

.PP
Definição na linha 114 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "Vector3f* IMU::_acel"
Ponteiro das medidas do acelerômetro 
.PP
Definição na linha 56 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin() e readSensor()\&.
.SS "uint8_t IMU::_address\fC [protected]\fP"

.PP
Definição na linha 103 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por IMU(), readRegisters() e writeRegister()\&.
.SS "int16_t IMU::_axcounts\fC [protected]\fP"
Contadores para leitura das medidas\&. 
.PP
Definição na linha 97 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "int16_t IMU::_aycounts\fC [protected]\fP"

.PP
Definição na linha 97 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "int16_t IMU::_azcounts\fC [protected]\fP"

.PP
Definição na linha 97 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "\fBDlpfBandwidth\fP IMU::_bandwidth\fC [protected]\fP"

.PP
Definição na linha 122 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin() e setDlpfBandwidth()\&.
.SS "Vector3f IMU::_biasAccel {\-0\&.37238f, \-0\&.109074f, 0\&.121389f}"
Vetor bias do acelerometro\&. 
.PP
\fBAtividades futuras\fP
.RS 4
A MARG eh capaz de registrar os bias/Offset nos resgistradores\&. Feito isso as medidas 
.br
 
.RE
.PP

.PP
Definição na linha 73 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por ekf::EKF::begin() e readSensor()\&.
.SS "Vector3f IMU::_biasGyro = Vector3f::Zero()"
Bias do Giroscópio\&. 
.PP
Definição na linha 76 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por ekf::EKF::begin(), calibraGyro() e readSensor()\&.
.SS "Vector3f IMU::_biasMag = Vector3f::Zero()"
Bias do Magnetômetro\&. 
.PP
Definição na linha 78 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por calibracaoMagnetometro() e readSensor()\&.
.SS "uint8_t IMU::_buffer[21]\fC [protected]\fP"
buffer de leitura do sensor 
.PP
Definição na linha 94 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin(), readAK8963Registers(), readSensor(), whoAmI(), whoAmIAK8963(), writeAK8963Register() e writeRegister()\&.
.SS "int16_t IMU::_gxcounts\fC [protected]\fP"

.PP
Definição na linha 98 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "int16_t IMU::_gycounts\fC [protected]\fP"

.PP
Definição na linha 98 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "Vector3f* IMU::_gyro"
Ponteiro das medidas do giroscópio 
.PP
Definição na linha 58 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin(), calibraGyro() e readSensor()\&.
.SS "\fBGyroRange\fP IMU::_gyroRange\fC [protected]\fP"

.PP
Definição na linha 118 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setGyroRange()\&.
.SS "float IMU::_gyroScale\fC [protected]\fP"

.PP
Definição na linha 115 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor() e setGyroRange()\&.
.SS "int16_t IMU::_gzcounts\fC [protected]\fP"

.PP
Definição na linha 98 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "int16_t IMU::_hxcounts\fC [protected]\fP"

.PP
Definição na linha 99 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "int16_t IMU::_hycounts\fC [protected]\fP"

.PP
Definição na linha 99 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "int16_t IMU::_hzcounts\fC [protected]\fP"

.PP
Definição na linha 99 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "TwoWire* IMU::_i2c"

.PP
Definição na linha 90 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin(), IMU(), readRegisters() e writeRegister()\&.
.SS "const uint32_t IMU::_i2cRate = 400000\fC [protected]\fP"

.PP
Definição na linha 108 do arquivo IMU\&.h\&.
.SS "Vector3f* IMU::_mag"
Ponteiro das medidas do Magnetômetro 
.PP
Definição na linha 60 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin() e readSensor()\&.
.SS "float IMU::_magScaleX\fC [protected]\fP"

.PP
Definição na linha 116 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin() e readSensor()\&.
.SS "float IMU::_magScaleY\fC [protected]\fP"

.PP
Definição na linha 116 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "float IMU::_magScaleZ\fC [protected]\fP"

.PP
Definição na linha 116 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "size_t IMU::_numBytes\fC [protected]\fP"

.PP
numero de bytes para leitura funcao readRegisters 
.PP
Definição na linha 105 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readRegisters()\&.
.SS "Matrix3f IMU::_sM = Matrix3f::Identity()"
Matriz fator de escala\&. 
.PP
Definição na linha 80 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por calibracaoMagnetometro()\&.
.SS "uint8_t IMU::_srd\fC [protected]\fP"

.PP
Definição na linha 123 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "int IMU::_status\fC [protected]\fP"

.PP
Definição na linha 110 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers()\&.
.SS "float IMU::_t"

.PP
Definição na linha 62 do arquivo IMU\&.h\&.
.SS "int16_t IMU::_tcounts\fC [protected]\fP"

.PP
Definição na linha 100 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::ACCEL_CONFIG = 0x1C\fC [protected]\fP"

.PP
Definição na linha 130 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "const uint8_t IMU::ACCEL_CONFIG2 = 0x1D\fC [protected]\fP"

.PP
Definição na linha 143 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_DLPF_10 = 0x05\fC [protected]\fP"

.PP
Definição na linha 148 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_DLPF_184 = 0x01\fC [protected]\fP"

.PP
Definição na linha 144 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_DLPF_20 = 0x04\fC [protected]\fP"

.PP
Definição na linha 147 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_DLPF_41 = 0x03\fC [protected]\fP"

.PP
Definição na linha 146 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_DLPF_5 = 0x06\fC [protected]\fP"

.PP
Definição na linha 149 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_DLPF_92 = 0x02\fC [protected]\fP"

.PP
Definição na linha 145 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::ACCEL_FS_SEL_16G = 0x18\fC [protected]\fP"

.PP
Definição na linha 137 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "const uint8_t IMU::ACCEL_FS_SEL_2G = 0x00\fC [protected]\fP"

.PP
Definição na linha 134 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "const uint8_t IMU::ACCEL_FS_SEL_4G = 0x08\fC [protected]\fP"

.PP
Definição na linha 135 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "const uint8_t IMU::ACCEL_FS_SEL_8G = 0x10\fC [protected]\fP"

.PP
Definição na linha 136 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "const uint8_t IMU::ACCEL_INTEL_EN = 0x80\fC [protected]\fP"

.PP
Definição na linha 182 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::ACCEL_INTEL_MODE = 0x40\fC [protected]\fP"

.PP
Definição na linha 183 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::ACCEL_OUT = 0x3B\fC [protected]\fP"

.PP
Definição na linha 126 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "const uint8_t IMU::AK8963_ASA = 0x10\fC [protected]\fP"

.PP
Definição na linha 204 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_CNT_MEAS1 = 0x12\fC [protected]\fP"

.PP
Definição na linha 199 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::AK8963_CNT_MEAS2 = 0x16\fC [protected]\fP"

.PP
Definição na linha 200 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_CNTL1 = 0x0A\fC [protected]\fP"

.PP
Definição na linha 197 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_CNTL2 = 0x0B\fC [protected]\fP"

.PP
Definição na linha 202 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_FUSE_ROM = 0x0F\fC [protected]\fP"

.PP
Definição na linha 201 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_HXL = 0x03\fC [protected]\fP"

.PP
Definição na linha 196 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_I2C_ADDR = 0x0C\fC [protected]\fP"

.PP
Definição na linha 195 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers() e writeAK8963Register()\&.
.SS "const uint8_t IMU::AK8963_PWR_DOWN = 0x00\fC [protected]\fP"

.PP
Definição na linha 198 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_RESET = 0x01\fC [protected]\fP"

.PP
Definição na linha 203 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::AK8963_WHO_AM_I = 0x00\fC [protected]\fP"

.PP
Definição na linha 205 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por whoAmIAK8963()\&.
.SS "const uint8_t IMU::CLOCK_SEL_PLL = 0x01\fC [protected]\fP"

.PP
Definição na linha 167 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::CONFIG = 0x1A\fC [protected]\fP"

.PP
Definição na linha 150 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::DIS_GYRO = 0x07\fC [protected]\fP"

.PP
Definição na linha 170 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::EXT_SENS_DATA_00 = 0x49\fC [protected]\fP"

.PP
Definição na linha 129 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers()\&.
.SS "const float IMU::gG = 9\&.786171951281709f\fC [protected]\fP"

.PP
Definição na linha 112 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setAccelRange()\&.
.SS "const uint8_t IMU::GYRO_CONFIG = 0x1B\fC [protected]\fP"

.PP
Definição na linha 138 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setGyroRange()\&.
.SS "const uint8_t IMU::GYRO_DLPF_10 = 0x05\fC [protected]\fP"

.PP
Definição na linha 155 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::GYRO_DLPF_184 = 0x01\fC [protected]\fP"

.PP
Definição na linha 151 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::GYRO_DLPF_20 = 0x04\fC [protected]\fP"

.PP
Definição na linha 154 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::GYRO_DLPF_41 = 0x03\fC [protected]\fP"

.PP
Definição na linha 153 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::GYRO_DLPF_5 = 0x06\fC [protected]\fP"

.PP
Definição na linha 156 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::GYRO_DLPF_92 = 0x02\fC [protected]\fP"

.PP
Definição na linha 152 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setDlpfBandwidth()\&.
.SS "const uint8_t IMU::GYRO_FS_SEL_1000DPS = 0x10\fC [protected]\fP"

.PP
Definição na linha 141 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setGyroRange()\&.
.SS "const uint8_t IMU::GYRO_FS_SEL_2000DPS = 0x18\fC [protected]\fP"

.PP
Definição na linha 142 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setGyroRange()\&.
.SS "const uint8_t IMU::GYRO_FS_SEL_250DPS = 0x00\fC [protected]\fP"

.PP
Definição na linha 139 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setGyroRange()\&.
.SS "const uint8_t IMU::GYRO_FS_SEL_500DPS = 0x08\fC [protected]\fP"

.PP
Definição na linha 140 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por setGyroRange()\&.
.SS "const uint8_t IMU::GYRO_OUT = 0x43\fC [protected]\fP"

.PP
Definição na linha 127 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::I2C_MST_CLK = 0x0D\fC [protected]\fP"

.PP
Definição na linha 173 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::I2C_MST_CTRL = 0x24\fC [protected]\fP"

.PP
Definição na linha 174 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::I2C_MST_EN = 0x20\fC [protected]\fP"

.PP
Definição na linha 172 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::I2C_READ_FLAG = 0x80\fC [protected]\fP"

.PP
Definição na linha 180 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers()\&.
.SS "const uint8_t IMU::I2C_SLV0_ADDR = 0x25\fC [protected]\fP"

.PP
Definição na linha 175 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers() e writeAK8963Register()\&.
.SS "const uint8_t IMU::I2C_SLV0_CTRL = 0x27\fC [protected]\fP"

.PP
Definição na linha 178 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers() e writeAK8963Register()\&.
.SS "const uint8_t IMU::I2C_SLV0_DO = 0x63\fC [protected]\fP"

.PP
Definição na linha 177 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por writeAK8963Register()\&.
.SS "const uint8_t IMU::I2C_SLV0_EN = 0x80\fC [protected]\fP"

.PP
Definição na linha 179 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers() e writeAK8963Register()\&.
.SS "const uint8_t IMU::I2C_SLV0_REG = 0x26\fC [protected]\fP"

.PP
Definição na linha 176 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readAK8963Registers() e writeAK8963Register()\&.
.SS "const uint8_t IMU::INT_DISABLE = 0x00\fC [protected]\fP"

.PP
Definição na linha 160 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::INT_ENABLE = 0x38\fC [protected]\fP"

.PP
Definição na linha 159 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::INT_PIN_CFG = 0x37\fC [protected]\fP"

.PP
Definição na linha 158 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::INT_PULSE_50US = 0x00\fC [protected]\fP"

.PP
Definição na linha 161 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::INT_RAW_RDY_EN = 0x01\fC [protected]\fP"

.PP
Definição na linha 163 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::INT_WOM_EN = 0x40\fC [protected]\fP"

.PP
Definição na linha 162 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::LP_ACCEL_ODR = 0x1E\fC [protected]\fP"

.PP
Definição na linha 184 do arquivo IMU\&.h\&.
.SS "Vector3f IMU::magTemp"

.PP
Definição na linha 61 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por calibracaoMagnetometro() e readSensor()\&.
.SS "const uint8_t IMU::MOT_DETECT_CTRL = 0x69\fC [protected]\fP"

.PP
Definição na linha 181 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::PWR_CYCLE = 0x20\fC [protected]\fP"

.PP
Definição na linha 165 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::PWR_MGMNT_1 = 0x6B\fC [protected]\fP"

.PP
Definição na linha 164 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::PWR_MGMNT_2 = 0x6C\fC [protected]\fP"

.PP
Definição na linha 168 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::PWR_RESET = 0x80\fC [protected]\fP"

.PP
Definição na linha 166 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::SEN_ENABLE = 0x00\fC [protected]\fP"

.PP
Definição na linha 169 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const Matrix3f IMU::sFAccel"
\fBValor inicial:\fP
.PP
.nf
=
      (Matrix3f() << 0\&.00477306f, -2\&.94365e-05, 3\&.90831e-05, 4\&.92044e-05,
       0\&.00477824f, 5\&.7648e-05, 1\&.55692e-05, -7\&.4314e-05, 0\&.00474654f)
          \&.finished()
.fi
Matriz fator de escala do acelerometro\&. 
.PP
Definição na linha 65 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por readSensor()\&.
.SS "const uint8_t IMU::SMPDIV = 0x19\fC [protected]\fP"

.PP
Definição na linha 157 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::TEMP_OUT = 0x41\fC [protected]\fP"

.PP
Definição na linha 128 do arquivo IMU\&.h\&.
.SS "const uint8_t IMU::USER_CTRL = 0x6A\fC [protected]\fP"

.PP
Definição na linha 171 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const uint8_t IMU::WHO_AM_I = 0x75\fC [protected]\fP"

.PP
Definição na linha 186 do arquivo IMU\&.h\&.
.PP
Referenciado(a) por whoAmI()\&.
.SS "const uint8_t IMU::WOM_THR = 0x1F\fC [protected]\fP"

.PP
Definição na linha 185 do arquivo IMU\&.h\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
