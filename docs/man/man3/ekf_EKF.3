.TH "ekf::EKF" 3 "Segunda, 25 de Outubro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ekf::EKF
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <EKF\&.h>\fP
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "\fBEKF\fP ()"
.br
.ti -1c
.RI "void \fBbegin\fP (float \fBdt\fP)"
.br
.RI "Inicializacao do filtro de Kalman\&. "
.ti -1c
.RI "void \fBloopEKF\fP ()"
.br
.in -1c
.SS "Campos de Dados"

.in +1c
.ti -1c
.RI "int \fBstatus\fP = \fBBEGIN\fP"
.br
.ti -1c
.RI "const int \fBnAtitude\fP = 6"
.br
.ti -1c
.RI "const int \fBpAtitude\fP = 4"
.br
.ti -1c
.RI "\fBBASE\fP \fBbase\fP"
.br
.ti -1c
.RI "float \fBdt\fP = 0\&.0f"
.br
.ti -1c
.RI "Eigen::Vector3f \fBaccel\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "const Eigen::Vector3f \fBnavegationGravity\fP {0\&.0f, 0\&.0f, 9\&.786171951281709f}"
.br
.ti -1c
.RI "Eigen::Vector3f \fBgyro\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBmag\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f \fBqObs\fP {1\&.0f, 0\&.0f, 0\&.0f, 0\&.0f}"
.br
.ti -1c
.RI "Eigen::Vector4f \fBq\fP {1\&.0f, 0\&.0f, 0\&.0f, 0\&.0f}"
.br
.ti -1c
.RI "Eigen::Vector3f \fBeuler\fP {0\&.0f, 0\&.0f, 0\&.0f}"
.br
.ti -1c
.RI "Eigen::Vector3f \fBrNED\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBrNEDgps\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBdrNED\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBdrNEDgps\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBddr\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Matrix3f \fBmcd\fP = Eigen::Matrix3f::Identity()"
.br
.ti -1c
.RI "uint8_t \fBmessageGPS\fP = 0"
.br
.ti -1c
.RI "int \fBp\fP = \fBpFull\fP"
.br
.ti -1c
.RI "int \fBn\fP = 15"
.br
.ti -1c
.RI "const float \fBsigma_giro_squared\fP = 1e\-3"
.br
.ti -1c
.RI "const float \fBsigma_bias_giro_squared\fP = 1e\-6"
.br
.ti -1c
.RI "const float \fBsigma_accel_squared\fP = 1e\-3"
.br
.ti -1c
.RI "const float \fBsigma_bias_accel_squared\fP = 1e\-6"
.br
.ti -1c
.RI "const float \fBsigma_aqua_squared\fP = 1e\-3"
.br
.ti -1c
.RI "const float \fBsigma_vel_squared\fP = 0\&.02f * 0\&.02f"
.br
.ti -1c
.RI "const float \fBsigma_pos_squared\fP = 5\&.0f * 5\&.0f"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBnFull\fP, \fBnFull\fP > \fBQ_k\fP"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBpFull\fP, \fBpFull\fP > \fBR\fP"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBnFull\fP, \fBnFull\fP > \fBmF\fP = Eigen::MatrixXf::Zero(\fBnFull\fP, \fBnFull\fP)"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBnFull\fP, \fBnFull\fP > \fBfi\fP = Eigen::MatrixXf::Zero(\fBnFull\fP, \fBnFull\fP)"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBnFull\fP, 12 > \fBG\fP = Eigen::MatrixXf::Zero(\fBnFull\fP, 12)"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBnFull\fP, \fBnFull\fP > \fBP\fP"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBpFull\fP, \fBnFull\fP > \fBH\fP = Eigen::MatrixXf::Zero(\fBpFull\fP, \fBnFull\fP)"
.br
.ti -1c
.RI "Eigen::Matrix< float, \fBnFull\fP, \fBpFull\fP > \fBK\fP"
.br
.ti -1c
.RI "Eigen::Vector< float, \fBnFull\fP+1 > \fBdeltaChi\fP = Eigen::VectorXf::Zero(\fBnFull\fP + 1)"
.br
.ti -1c
.RI "Eigen::Vector< float, \fBpFull\fP > \fBdeltaYObs\fP = Eigen::VectorXf::Zero(\fBpFull\fP)"
.br
.ti -1c
.RI "Eigen::Vector3f * \fBbiasGyro\fP"
.br
.ti -1c
.RI "Eigen::Vector3f * \fBbiasAccel\fP"
.br
.in -1c
.SS "Atributos Estáticos Públicos"

.in +1c
.ti -1c
.RI "static const int \fBnFull\fP = 15"
.br
.ti -1c
.RI "static const int \fBpFull\fP = 7"
.br
.in -1c
.SS "Atributos Privados"

.in +1c
.ti -1c
.RI "const float \fBDEG_TO_RAD_BY_10000000\fP"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 45 do arquivo EKF\&.h\&.
.SH "Construtores e Destrutores"
.PP 
.SS "ekf::EKF::EKF ()"

.PP
Definição na linha 33 do arquivo EKF\&.cpp\&.
.PP
.nf
33 {}
.fi
.SH "Funções membros"
.PP 
.SS "void ekf::EKF::begin (float _dt)"

.PP
Inicializacao do filtro de Kalman\&. Inicializa e configura:o GPS, a classe timeClass, instancia os sensores \fBaccel\fP, \fBgyro\fP e \fBmag\fP; e Configura os valores padrões da matrizes #F, \fBG\fP e \fBH\fP\&. HACK: 
.PP
\fB( ͡❛ ͜ʖ ͡❛) \fP
.RS 4

.br
 \fBaccel\fP, \fBgyro\fP e \fBmag\fP são ponteiros\&. Quando as medidas são atualizadas na biblioteca \fBIMU\fP, o vetor é modificado na \fBEKF\fP\&. 
.RE
.PP

.PP
Definição na linha 40 do arquivo EKF\&.cpp\&.
.PP
.nf
40                          {
41 #ifdef __XTENSA__
42   printf("Nucleo do Filtro: %d\n", xPortGetCoreID());
43 #endif
44   status = BEGIN;
45   this->dt = _dt;
46 #ifdef __XTENSA__
47   gpsSetup();
48 
49   timeClass\&.begin();
50   // timeClassLoop\&.begin();
51 
52 #endif
53 
54   // Instancia o vetor de medidas na biblioteca da IMU\&.
57 #ifdef __XTENSA__
58   imu\&.begin(accel, gyro, mag);
59   // referencia o bias da classe IMU\&.
60   biasGyro = &imu\&._biasGyro;
61   biasAccel = &imu\&._biasAccel;
62 #endif
63   // Atualiza valor do bias do giroscópio com uma média de amostras
64   // valores constantes das matriz F
65   mF\&.block<3, 3>(0, 3) = -0\&.5f * Eigen::Matrix3f::Identity();
66   mF\&.block<3, 3>(12, 6) = Eigen::Matrix3f::Identity();
67   // Valores constantes da matriz G
68   G\&.topLeftCorner(3, 3) = -0\&.5f * Eigen::Matrix3f::Identity();
69   G\&.block<3, 3>(3, 3) = Eigen::Matrix3f::Identity();
70   G\&.block(6, 6, 3, 3) = -Eigen::Matrix3f::Identity();
71   G\&.block<3, 3>(9, 9) = Eigen::Matrix3f::Identity();
72   // matrix de covariâncias do processo continuo
73   Eigen::MatrixXf Q = Eigen::MatrixXf::Identity(12, 12);
74   Eigen::Matrix3f _I = Eigen::Matrix3f::Identity();
75   Q\&.block<3, 3>(0, 0) = _I * _dt * _dt * sigma_giro_squared;
76   Q\&.block<3, 3>(3, 3) = _I * _dt * sigma_bias_giro_squared;
77   Q\&.block<3, 3>(6, 6) = _I * _dt * _dt * sigma_accel_squared;
78   Q\&.block<3, 3>(9, 9) = _I * _dt * sigma_bias_accel_squared;
79   Q_k = G * Q * G\&.transpose();
80   R\&.block<4, 4>(0, 0) = Eigen::Matrix4f::Identity() * sigma_aqua_squared;
81 
82 #ifndef __XTENSA__
83   // Q_k = csvLeia<Eigen::MatrixXf>("Q");
84   // R = csvLeia<Eigen::MatrixXf>("R");
85 #endif
86   // condições iniciais da posicao
87   aqua\&.begin(qObs, accel, mag);
88 #ifdef __XTENSA__
89   updateBaseRef();
90   imu\&.readSensor();
91 #endif
92   // valor inicial a partir da medida
93   aqua\&.computeAQUAQuaternion();
94   q = qObs;
95   // aqua\&.qAlignment = qObs;
96   status = READY;
97 }
.fi
.PP
Referencias IMU::_biasAccel, IMU::_biasGyro, accel, ekf::aqua, ekf::BEGIN, TIME::begin(), AQUA::begin(), IMU::begin(), biasAccel, biasGyro, AQUA::computeAQUAQuaternion(), dt, G, gpsSetup(), gyro, mag, mF, q, Q_k, qObs, R, IMU::readSensor(), ekf::READY, sigma_accel_squared, sigma_aqua_squared, sigma_bias_accel_squared, sigma_bias_giro_squared, sigma_giro_squared e status\&.
.PP
Referenciado(a) por setup() e xTaskSetupFiltro()\&.
.SS "void ekf::EKF::loopEKF ()"
Loop do Filtro de Kalman 
.PP
Definição na linha 101 do arquivo EKF\&.cpp\&.
.PP
.nf
101                   {
102   // le os sensores
103   // timeClassLoop\&.computeElapsedTime();
104   updateOfMeasurements();
105   predictionStage();
106   updateStage();
107   updateStates();
108   // dtLoop = timeClassLoop\&.computeElapsedTime();
109 }
.fi
.PP
Referenciado(a) por xTaskLoopFilter()\&.
.SH "Campos"
.PP 
.SS "Eigen::Vector3f ekf::EKF::accel = Eigen::Vector3f::Zero()"
Vetor com as medidas do acelerometro 
.PP
Definição na linha 70 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin() e loop()\&.
.SS "\fBBASE\fP ekf::EKF::base"

.PP
Definição na linha 62 do arquivo EKF\&.h\&.
.SS "Eigen::Vector3f* ekf::EKF::biasAccel"
Vetor ponteiro do bias do acelerômetro 
.PP
Definição na linha 177 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f* ekf::EKF::biasGyro"
Observações preditas */ Eigen::VectorXf yPreditas = Eigen::VectorXf::Zero(15); void integrationOfStates(); void updateStates(); void predictionStage(); void updateStage(); void updateF(); void updateFi(); void updateHq(); void updateHv(); void updateHp();
.PP
void updateOfMeasurements(); void positionIntegration(); void updateBaseRef(); void updateNedPos(); void updateNedVel();
.PP
/*! Vetor ponteiro do bias do giroscópio 
.PP
Definição na linha 175 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f ekf::EKF::ddr = Eigen::Vector3f::Zero()"
Aceleração linear m/s^2 
.PP
Definição na linha 98 do arquivo EKF\&.h\&.
.SS "const float ekf::EKF::DEG_TO_RAD_BY_10000000\fC [private]\fP"
\fBValor inicial:\fP
.PP
.nf
=
      1e-7 / 57\&.295779513082320876798154814105f
.fi
.PP
Definição na linha 47 do arquivo EKF\&.h\&.
.SS "Eigen::Vector<float, \fBnFull\fP + 1> ekf::EKF::deltaChi = Eigen::VectorXf::Zero(\fBnFull\fP + 1)"
Vetor de estados perturbados do estados estimados do \fBEKF\fP\&. 
.PP
\fBAviso\fP
.RS 4
deltaChi possui dimensão 15+1, o primeiro elemento não é calculado pelo filtro mas computado na #updateStates()\&. 
.RE
.PP

.PP
Definição na linha 150 do arquivo EKF\&.h\&.
.SS "Eigen::Vector<float, \fBpFull\fP> ekf::EKF::deltaYObs = Eigen::VectorXf::Zero(\fBpFull\fP)"
Erro das observações 
.PP
Definição na linha 152 do arquivo EKF\&.h\&.
.SS "Eigen::Vector3f ekf::EKF::drNED = Eigen::Vector3f::Zero()"
Velocidade linear m/s 
.PP
Definição na linha 94 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por xTaskContol() e xTaskLoopFilter()\&.
.SS "Eigen::Vector3f ekf::EKF::drNEDgps = Eigen::Vector3f::Zero()"
Velocidade linear sistema NED de observação\&. 
.PP
Definição na linha 96 do arquivo EKF\&.h\&.
.SS "float ekf::EKF::dt = 0\&.0f"
Intervalo de tempo do Loop\&.
.PP
Intervalo de tempo para integração da atitude 
.PP
Definição na linha 68 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f ekf::EKF::euler {0\&.0f, 0\&.0f, 0\&.0f}"
Ângulos de Euler na convenção 3-2-1 Tait-Bryan 
.PP
Definição na linha 84 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por xTaskLoopFilter()\&.
.SS "Eigen::Matrix<float, \fBnFull\fP, \fBnFull\fP> ekf::EKF::fi = Eigen::MatrixXf::Zero(\fBnFull\fP, \fBnFull\fP)"
Matriz Jacobiana dos estados\&. 
.PP
Definição na linha 131 do arquivo EKF\&.h\&.
.SS "Eigen::Matrix<float, \fBnFull\fP, 12> ekf::EKF::G = Eigen::MatrixXf::Zero(\fBnFull\fP, 12)"
Matriz G de ruido do processo\&. 
.PP
Definição na linha 133 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f ekf::EKF::gyro = Eigen::Vector3f::Zero()"
Vetor com as medidas do giroscopios 
.PP
Definição na linha 74 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin(), loop(), xTaskContol() e xTaskLoopFilter()\&.
.SS "Eigen::Matrix<float, \fBpFull\fP, \fBnFull\fP> ekf::EKF::H = Eigen::MatrixXf::Zero(\fBpFull\fP, \fBnFull\fP)"
Matriz sensibilidade 
.PP
Definição na linha 141 do arquivo EKF\&.h\&.
.SS "Eigen::Matrix<float, \fBnFull\fP, \fBpFull\fP> ekf::EKF::K"
\fBValor inicial:\fP
.PP
.nf
=
      Eigen::MatrixXf::Identity(nFull, pFull)
.fi
Ganho de Kalman 
.PP
Definição na linha 143 do arquivo EKF\&.h\&.
.SS "Eigen::Vector3f ekf::EKF::mag = Eigen::Vector3f::Zero()"
Vetor com as medidas do magnetometros 
.PP
Definição na linha 76 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin() e loop()\&.
.SS "Eigen::Matrix3f ekf::EKF::mcd = Eigen::Matrix3f::Identity()"
Matrix de cossenos diretores 
.PP
Definição na linha 100 do arquivo EKF\&.h\&.
.SS "uint8_t ekf::EKF::messageGPS = 0"

.PP
Definição na linha 101 do arquivo EKF\&.h\&.
.SS "Eigen::Matrix<float, \fBnFull\fP, \fBnFull\fP> ekf::EKF::mF = Eigen::MatrixXf::Zero(\fBnFull\fP, \fBnFull\fP)"
Matrix de estados linearizada\&. 
.PP
\fBObservação\fP
.RS 4
mF é utilizado como simbolo de F pq F é um simbolo reservado\&. 
.RE
.PP

.PP
Definição na linha 129 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "int ekf::EKF::n = 15"
Números de estados\&. q, b_giro, vel, b_accel, posicao 
.PP
Definição na linha 106 do arquivo EKF\&.h\&.
.SS "const int ekf::EKF::nAtitude = 6"
Número de estados de atitude\&. 
.PP
Definição na linha 58 do arquivo EKF\&.h\&.
.SS "const Eigen::Vector3f ekf::EKF::navegationGravity {0\&.0f, 0\&.0f, 9\&.786171951281709f}"
Gravidade no sistema de navegação 
.PP
Definição na linha 72 do arquivo EKF\&.h\&.
.SS "const int ekf::EKF::nFull = 15\fC [static]\fP"
Número de estados do sistema completo\&. 
.PP
Definição na linha 54 do arquivo EKF\&.h\&.
.SS "int ekf::EKF::p = \fBpFull\fP"
Número de linhas da matriz H\&. Assume 3 quando apenas a MARG está disponível e 6 quando MARG/GPS estão disponíveis\&. 
.PP
Definição na linha 104 do arquivo EKF\&.h\&.
.SS "Eigen::Matrix<float, \fBnFull\fP, \fBnFull\fP> ekf::EKF::P"
\fBValor inicial:\fP
.PP
.nf
=
      ((Eigen::VectorXf(n) << \&.5, \&.5, \&.5, \&.1, \&.10, \&.10, 1, 1, 1, \&.1, \&.10, \&.10,
        1e8, 1e8, 1e8)
           \&.finished())
          \&.asDiagonal()
.fi
Matriz Covariancia 
.PP
Definição na linha 135 do arquivo EKF\&.h\&.
.SS "const int ekf::EKF::pAtitude = 4"
Número de observações da atitude 
.PP
Definição na linha 60 do arquivo EKF\&.h\&.
.SS "const int ekf::EKF::pFull = 7\fC [static]\fP"
Número total de observações 
.PP
Definição na linha 56 do arquivo EKF\&.h\&.
.SS "Eigen::Vector4f ekf::EKF::q {1\&.0f, 0\&.0f, 0\&.0f, 0\&.0f}"
Quaternion de atitude 
.PP
Definição na linha 82 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin(), drone\&.Drone::updateStates(), xTaskContol() e xTaskLoopFilter()\&.
.SS "Eigen::Matrix<float, \fBnFull\fP, \fBnFull\fP> ekf::EKF::Q_k"
\fBValor inicial:\fP
.PP
.nf
=
      Eigen::MatrixXf::Identity(nFull, nFull)
.fi
Matriz de covariancia de processo discretizada\&. 
.PP
Definição na linha 122 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector4f ekf::EKF::qObs {1\&.0f, 0\&.0f, 0\&.0f, 0\&.0f}"
Vetor com as medias do magnetometro sem as projeções na direção do vetor gravitacional
.PP
Quaternion de observação 
.PP
Definição na linha 80 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Matrix<float, \fBpFull\fP, \fBpFull\fP> ekf::EKF::R"
\fBValor inicial:\fP
.PP
.nf
=
      Eigen::MatrixXf::Identity(pFull, pFull)
.fi
Matriz de covariancia de medidas\&. 
.PP
Definição na linha 125 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f ekf::EKF::rNED = Eigen::Vector3f::Zero()"
Vetor de estados estimados do \fBEKF\fP\&. O erros são: as três componetes da parte vetorial do quaternion, os três bias do giroscópio e as compoenentes da velocidade no sistema NED\&. [ \fBq\fP \fBb\fP \fBr\fP]
.PP
Posicoes no sistema NED 
.PP
Definição na linha 90 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por xTaskContol()\&.
.SS "Eigen::Vector3f ekf::EKF::rNEDgps = Eigen::Vector3f::Zero()"
Posicao no sistema NED de observação\&. 
.PP
Definição na linha 92 do arquivo EKF\&.h\&.
.SS "const float ekf::EKF::sigma_accel_squared = 1e\-3"
Quadrado do desvio padrão do acelerômetro\&. 
.PP
Definição na linha 112 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const float ekf::EKF::sigma_aqua_squared = 1e\-3"
Quadrado do desvio padrão da observação do quatérnion\&. 
.PP
Definição na linha 116 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const float ekf::EKF::sigma_bias_accel_squared = 1e\-6"
Quadrado do desvio padrão do bias do acelerômetro\&. 
.PP
Definição na linha 114 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const float ekf::EKF::sigma_bias_giro_squared = 1e\-6"
Quadrado do desvio padrão do bias do giroscópio\&. 
.PP
Definição na linha 110 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const float ekf::EKF::sigma_giro_squared = 1e\-3"
Quadrado do desvio padrão do giroscópio\&. 
.PP
Definição na linha 108 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "const float ekf::EKF::sigma_pos_squared = 5\&.0f * 5\&.0f"
Quadrado do desvio padrão da posição no gps\&. 
.PP
Definição na linha 120 do arquivo EKF\&.h\&.
.SS "const float ekf::EKF::sigma_vel_squared = 0\&.02f * 0\&.02f"
Quadrado do desvio padrão da velocidade no gps\&. 
.PP
Definição na linha 118 do arquivo EKF\&.h\&.
.SS "int ekf::EKF::status = \fBBEGIN\fP"
Status do filtro 
.PP
Definição na linha 52 do arquivo EKF\&.h\&.
.PP
Referenciado(a) por begin(), xTaskContol() e xTaskLoopFilter()\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
