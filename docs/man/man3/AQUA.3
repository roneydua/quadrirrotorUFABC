.TH "AQUA" 3 "Segunda, 25 de Outubro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AQUA
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <AQUA\&.h>\fP
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "\fBAQUA\fP ()"
.br
.ti -1c
.RI "void \fBgetInitialAlignment\fP (Eigen::Vector4f &)"
.br
.ti -1c
.RI "void \fBbegin\fP (Eigen::Vector4f &_qObs, Eigen::Vector3f &\fBaccel\fP, Eigen::Vector3f &\fBmag\fP)"
.br
.ti -1c
.RI "int \fBcomputeAQUAQuaternion\fP ()"
.br
.ti -1c
.RI "void \fBcomputeQuaternionAccel\fP ()"
.br
.RI "Calcula o quaternion de inclinacao\&. "
.ti -1c
.RI "void \fBcomputeQuaternionMag\fP ()"
.br
.in -1c
.SS "Campos de Dados"

.in +1c
.ti -1c
.RI "Eigen::Vector4f \fBqAcc\fP = Eigen::Vector4f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f \fBqMag\fP = Eigen::Vector4f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBnormalizedGravity\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBmagNormalized\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector3f \fBl\fP = Eigen::Vector3f::Zero()"
.br
.ti -1c
.RI "Eigen::Vector4f * \fBqAQUA\fP"
.br
.ti -1c
.RI "Eigen::Vector3f * \fBaccel\fP"
.br
.ti -1c
.RI "Eigen::Vector3f * \fBmag\fP"
.br
.ti -1c
.RI "Eigen::Vector4f \fBqAlignment\fP {1\&.0f, 0\&.0f, 0\&.0f, 0\&.0f}"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 21 do arquivo AQUA\&.h\&.
.SH "Construtores e Destrutores"
.PP 
.SS "AQUA::AQUA ()"
Instância da classe \fBAQUA\fP\&. 
.PP
Definição na linha 17 do arquivo AQUA\&.cpp\&.
.PP
.nf
17 {}
.fi
.SH "Funções membros"
.PP 
.SS "void AQUA::begin (Eigen::Vector4f & _qObs, Eigen::Vector3f & accel, Eigen::Vector3f & mag)"

.PP
Definição na linha 18 do arquivo AQUA\&.cpp\&.
.PP
.nf
19                                      {
20   qAQUA = &_qObs;
21   this->accel = &accel;
22   this->mag = &mag;
23 }
.fi
.PP
Referencias accel, mag e qAQUA\&.
.PP
Referenciado(a) por ekf::EKF::begin()\&.
.SS "int AQUA::computeAQUAQuaternion ()"
Calcula o quaternion de atitude com o algoritimo \fBAQUA\fP\&. 
.PP
\fBRetorna\fP
.RS 4
0 se falhar ou 1 se sucesso\&. 
.RE
.PP

.PP
Definição na linha 73 do arquivo AQUA\&.cpp\&.
.PP
.nf
73                                 {
74   Eigen::Vector4f _qLast = *qAQUA;
75   normalizedGravity = (*accel)\&.normalized();
76   magNormalized = (*mag)\&.normalized();
77   computeQuaternionAccel();
78   l = rotateVectorWithQuaternion_Conjugate(qAcc, magNormalized);
79   // leva as medidas do magnetometro para o sistema intermediario;
80   computeQuaternionMag();
81   *qAQUA = multiplyQuaternions(qAcc, qMag);
82   (*qAQUA)\&.tail(3) *= -1\&.0f;
83   if (_qLast\&.dot((*qAQUA)) < 0\&.0f) {
84     (*qAQUA) *= -1\&.0f;
85   }
86   // ajusta o desalinhamento
87   // (*qAQUA) = multiplyQuaternions(qAlignment, (*qAQUA));
88   return 1;
89 }
.fi
.PP
Referencias computeQuaternionAccel(), computeQuaternionMag(), l, magNormalized, ekf::multiplyQuaternions(), normalizedGravity, qAcc, qAQUA, qMag e ekf::rotateVectorWithQuaternion_Conjugate()\&.
.PP
Referenciado(a) por ekf::EKF::begin()\&.
.SS "void AQUA::computeQuaternionAccel ()"

.PP
Calcula o quaternion de inclinacao\&. 
.PP
Definição na linha 28 do arquivo AQUA\&.cpp\&.
.PP
.nf
28                                   {
29 
30   if (normalizedGravity(2) < 0) {
31     qAcc(1) = INVERSE_SQUARE_2 * sqrtf(1\&.0 - normalizedGravity(2));
32     float _k = 0\&.5f / qAcc(1);
33     qAcc(0) = -_k * normalizedGravity(1);
34     qAcc(2) = 0\&.0f;
35     qAcc(3) = _k * normalizedGravity(0);
36   } else {
37     qAcc(0) = INVERSE_SQUARE_2 * sqrtf(1\&.0 + normalizedGravity(2));
38     float _k = 0\&.5f / qAcc(0);
39     qAcc(1) = -_k * normalizedGravity(1);
40     qAcc(2) = _k * normalizedGravity(0);
41     qAcc(3) = 0\&.0f;
42   }
43 }
.fi
.PP
Referencias INVERSE_SQUARE_2, normalizedGravity e qAcc\&.
.PP
Referenciado(a) por computeAQUAQuaternion()\&.
.SS "void AQUA::computeQuaternionMag ()"
Computa o quaternion de guinada\&. 
.PP
Definição na linha 47 do arquivo AQUA\&.cpp\&.
.PP
.nf
47                                 {
48   float gama = l(0) * l(0) + l(1) * l(1);
49   if (l(0) < 0) {
50     float k3 = sqrtf(gama - l(0) * sqrtf(gama));
51     qMag(3) = INVERSE_SQUARE_2 * k3 * invSqrt(gama);
52     qMag(0) = INVERSE_SQUARE_2 * l(1) / k3;
53   } else {
54     float k3 = sqrtf(gama + l(0) * sqrtf(gama));
55     qMag(0) = INVERSE_SQUARE_2 * k3 * invSqrt(gama);
56     qMag(3) = INVERSE_SQUARE_2 * l(1) / k3;
57   }
58 }
.fi
.PP
Referencias INVERSE_SQUARE_2, ekf::invSqrt(), l e qMag\&.
.PP
Referenciado(a) por computeAQUAQuaternion()\&.
.SS "void AQUA::getInitialAlignment (Eigen::Vector4f &)"

.SH "Campos"
.PP 
.SS "Eigen::Vector3f* AQUA::accel"
Ponteiros do acelerometro e do magnetometro 
.PP
Definição na linha 38 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f AQUA::l = Eigen::Vector3f::Zero()"
Campo magnetico expresso no sistema intermediario 
.PP
Definição na linha 34 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por computeAQUAQuaternion() e computeQuaternionMag()\&.
.SS "Eigen::Vector3f * AQUA::mag"

.PP
Definição na linha 38 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por begin()\&.
.SS "Eigen::Vector3f AQUA::magNormalized = Eigen::Vector3f::Zero()"
Campo magnetico normalizado no sistema do corpo 
.PP
Definição na linha 32 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por computeAQUAQuaternion()\&.
.SS "Eigen::Vector3f AQUA::normalizedGravity = Eigen::Vector3f::Zero()"
Campo gravitacional normalizado no sistema do corpo 
.PP
Definição na linha 30 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por computeAQUAQuaternion() e computeQuaternionAccel()\&.
.SS "Eigen::Vector4f AQUA::qAcc = Eigen::Vector4f::Zero()"
Quaternion de inclinacao\&. 
.PP
Definição na linha 26 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por computeAQUAQuaternion() e computeQuaternionAccel()\&.
.SS "Eigen::Vector4f AQUA::qAlignment {1\&.0f, 0\&.0f, 0\&.0f, 0\&.0f}"
Quaternion de desalinhamento\&. 
.PP
Definição na linha 40 do arquivo AQUA\&.h\&.
.SS "Eigen::Vector4f* AQUA::qAQUA"
Ponteiro do quaternion de atitude\&. 
.PP
Definição na linha 36 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por begin() e computeAQUAQuaternion()\&.
.SS "Eigen::Vector4f AQUA::qMag = Eigen::Vector4f::Zero()"
Quaternion de Guinada\&. 
.PP
Definição na linha 28 do arquivo AQUA\&.h\&.
.PP
Referenciado(a) por computeAQUAQuaternion() e computeQuaternionMag()\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
