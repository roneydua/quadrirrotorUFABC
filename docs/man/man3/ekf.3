.TH "ekf" 3 "Segunda, 25 de Outubro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ekf \- Funções genéricas com álgebra de quatérnions e demais\&.  

.SH SYNOPSIS
.br
.PP
.SS "Estruturas de Dados"

.in +1c
.ti -1c
.RI "class \fBEKF\fP"
.br
.in -1c
.SS "Enumerações"

.in +1c
.ti -1c
.RI "enum \fB_status\fP { \fBBEGIN\fP, \fBREADY\fP, \fBFAIL\fP, \fBSTOPED\fP }"
.br
.in -1c
.SS "Funções"

.in +1c
.ti -1c
.RI "Eigen::MatrixXf \fBQ_r\fP (const Eigen::Ref< Eigen::Vector4f > &q)"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBQ_l\fP (const Eigen::Ref< Eigen::Vector4f > &q)"
.br
.ti -1c
.RI "Eigen::Matrix3f \fBskew\fP (const Eigen::Vector3f &v)"
.br
.RI "Matrix antissimetrica\&. "
.ti -1c
.RI "Eigen::Matrix4f \fBS_r\fP (const Eigen::Ref< Eigen::Vector4f > q)"
.br
.RI "Calcula a Matriz \fIRight-Quaternion\fP a partir do quaternion q\&. "
.ti -1c
.RI "Eigen::Matrix4f \fBS_l\fP (const Eigen::Ref< Eigen::Vector4f > &q)"
.br
.RI "Calcula a Matriz \fILeft-Quaternion\fP a partir do quaternion q\&. "
.ti -1c
.RI "void \fBcomputeMcdFromQuaternion\fP (const Eigen::Vector4f &q, Eigen::Matrix3f &mcd)"
.br
.ti -1c
.RI "void \fBprintEigen\fP (const Eigen::MatrixXf &m)"
.br
.ti -1c
.RI "Eigen::Vector3f \fBcomputeVectorProjection\fP (const Eigen::Ref< Eigen::Vector3f > &v, const Eigen::Ref< Eigen::Vector3f > &u)"
.br
.ti -1c
.RI "Eigen::Vector4f \fBmultiplyQuaternions\fP (const Eigen::Ref< Eigen::VectorXf > &p, const Eigen::Ref< Eigen::VectorXf > &q)"
.br
.RI "Produto de quaternions aplicado\&. "
.ti -1c
.RI "void \fBquaternion2Euler\fP (Eigen::Ref< Eigen::Vector3f > _euler, const Eigen::Ref< const Eigen::Vector4f > &_q)"
.br
.ti -1c
.RI "void \fBcalc_phi\fP (float &x, const Eigen::Ref< const Eigen::Vector4f > &_q)"
.br
.RI "Calcula, a partir de um quatérnio de atitude, o valor do ângulo Phi em Radianos\&. "
.ti -1c
.RI "void \fBcalc_theta\fP (float &x, const Eigen::Ref< const Eigen::Vector4f > &_q)"
.br
.RI "Calcula, a partir de um quatérnio de atitude, o valor do ângulo Theta em Radianos\&. "
.ti -1c
.RI "void \fBcalc_psi\fP (float &x, const Eigen::Ref< const Eigen::Vector4f > &_q)"
.br
.RI "Calcula, a partir de um quatérnio de atitude, o valor do ângulo Psi em Radianos\&. "
.ti -1c
.RI "void \fBintegrationQuaternion\fP (Eigen::Vector4f &_quat, const Eigen::Ref< const Eigen::VectorXf > &_gyroscope, float &_dt)"
.br
.ti -1c
.RI "Eigen::Vector3f \fBrotateVectorWithQuaternion\fP (Eigen::Vector4f &q, Eigen::Vector3f &v_old)"
.br
.RI "Rotaciona um vetor tridimensional com um quaternion\&. "
.ti -1c
.RI "Eigen::Vector3f \fBrotateVectorWithQuaternion_Conjugate\fP (Eigen::Vector4f &q, Eigen::Vector3f &v_old)"
.br
.RI "Rotaciona um vetor tridimensional com um quaternion conjugado\&. "
.ti -1c
.RI "float \fBinvSqrt\fP (float _x)"
.br
.RI "Calcula o inverso do raiz de um float\&. "
.ti -1c
.RI "Eigen::Vector4f \fBq_theta\fP (float &phi)"
.br
.RI "Calcula o quaternion de atitude de rotação phi sobre o eixo x\&. "
.ti -1c
.RI "Eigen::Vector4f \fBq_phi\fP (float &theta)"
.br
.RI "Calcula o quaternion de atitude de rotação theta sobre o eixo y\&. "
.ti -1c
.RI "Eigen::Vector4f \fBq_psi\fP (float &psi)"
.br
.RI "Calcula o quaternion de atitude de rotação psi sobre o eixo z\&. "
.ti -1c
.RI "void \fBcomputeQuaternionFromMCDMarkley\fP (Eigen::Matrix3f &m, Eigen::Ref< Eigen::Vector4f > q)"
.br
.ti -1c
.RI "Eigen::VectorXf \fBRK\fP (float h, const Eigen ::Ref< Eigen::VectorXf > &xk, const Eigen ::Ref< Eigen::VectorXf > &u, Eigen::VectorXf(fn)(Eigen::VectorXf x, Eigen::VectorXf u))"
.br
.ti -1c
.RI "void \fBconjugate\fP (Eigen::Ref< Eigen::Vector4f > _q)"
.br
.RI "Conjuga o quaternion _q\&. "
.ti -1c
.RI "Eigen::Matrix4f \fBS_r\fP (const Eigen::Ref< Eigen::Vector4f > &q)"
.br
.ti -1c
.RI "void \fBcomputeQuaternionFromMCDShepperd\fP (Eigen::Matrix3f &m, Eigen::Vector4f &q)"
.br
.ti -1c
.RI "Eigen::VectorXf \fBRK\fP (float h, const Eigen ::Ref< Eigen::VectorXf > &xk, const Eigen ::Ref< Eigen::VectorXf > &u, Eigen::VectorXf fn(Eigen::VectorXf x, Eigen::VectorXf u))"
.br
.in -1c
.SS "Variáveis"

.in +1c
.ti -1c
.RI "\fBAQUA\fP \fBaqua\fP"
.br
.ti -1c
.RI "const float \fBTOLERANCE\fP = 1e\-6"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Funções genéricas com álgebra de quatérnions e demais\&. 
.SH "Enumerações"
.PP 
.SS "enum \fBekf::_status\fP"
Enum Status Filter 
.PP
\fBEnumeradores\fP
.in +1c
.TP
\fB\fIBEGIN \fP\fP
.TP
\fB\fIREADY \fP\fP
.TP
\fB\fIFAIL \fP\fP
.TP
\fB\fISTOPED \fP\fP
.PP
Definição na linha 44 do arquivo EKF\&.h\&.
.PP
.nf
44 { BEGIN, READY, FAIL, STOPED };
.fi
.SH "Funções"
.PP 
.SS "void ekf::calc_phi (float & x, const Eigen::Ref< const Eigen::Vector4f > & _q)"

.PP
Calcula, a partir de um quatérnio de atitude, o valor do ângulo Phi em Radianos\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIx\fP Referencia a ser sobrescrita\&. -pi < x < pi 
.br
\fI_q\fP Quaternion de atitude 
.RE
.PP

.PP
Definição na linha 173 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
173                                                                  {
174   x = -atan2f(_q(2) * _q(3) - _q(0) * _q(1),
175               _q(0) * _q(0) + _q(3) * _q(3) - 0\&.5f);
176 }
.fi
.PP
Referenciado(a) por quaternion2Euler()\&.
.SS "void ekf::calc_psi (float & x, const Eigen::Ref< const Eigen::Vector4f > & _q)"

.PP
Calcula, a partir de um quatérnio de atitude, o valor do ângulo Psi em Radianos\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIx\fP Referencia a ser sobrescrita\&. -pi < x < pi 
.br
\fI_q\fP Quaternion de atitude 
.RE
.PP

.PP
Definição na linha 194 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
194                                                                  {
195   x = -atan2f(_q(1) * _q(2) - _q(0) * _q(3),
196               _q(0) * _q(0) + _q(1) * _q(1) - 0\&.5f);
197 }
.fi
.PP
Referenciado(a) por Controle::Controle() e quaternion2Euler()\&.
.SS "void ekf::calc_theta (float & x, const Eigen::Ref< const Eigen::Vector4f > & _q)"

.PP
Calcula, a partir de um quatérnio de atitude, o valor do ângulo Theta em Radianos\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIx\fP Referencia a ser sobrescrita\&. -pi/2 < x < pi/2 
.br
\fI_q\fP Quaternion de atitude 
.RE
.PP

.PP
Definição na linha 184 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
184                                                                    {
185   x = -asinf(-2\&.0f * (_q(0) * _q(2) + _q(1) * _q(3)));
186 }
.fi
.PP
Referenciado(a) por quaternion2Euler()\&.
.SS "void ekf::computeMcdFromQuaternion (const Eigen::Vector4f & q, Eigen::Matrix3f & mcd)"
Calcula a matriz de cossenos ditores a parir do quaternion de atitude 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.br
\fImcd\fP Matriz de cossenos diretores a ser atualizada (Referencia) 
.RE
.PP

.PP
Definição na linha 102 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
102                                                                           {
103   mcd = Eigen::Matrix3f::Identity() * (2\&.0f * q(0) * q(0) - 1\&.0f) +
104         2\&.0f * (q\&.tail(3) * q\&.tail(3)\&.transpose()) +
105         2\&.0f * q(0) * skew(q\&.tail(3));
106 }
.fi
.PP
Referencias skew()\&.
.SS "void ekf::computeQuaternionFromMCDMarkley (Eigen::Matrix3f & m, Eigen::Ref< Eigen::Vector4f > q)"
Extrai o quatérnio a partir da matrix de cossenos diretores\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIm\fP Matrix de cossenos diretores\&. 
.br
\fIq\fP Quaternion de atitude\&. 
.RE
.PP
\fBObservação\fP
.RS 4
Utiza o algoritmo BUG 
.RE
.PP

.PP
Definição na linha 350 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
351                                                                 {
352   Eigen::Vector4f indexVector;
353   float _trace = m\&.trace();
354   indexVector << _trace, m\&.diagonal();
355   Eigen::Vector4f::Index max_index;
356   indexVector\&.maxCoeff(&max_index);
357   switch (max_index) {
358   case 0:
359     q(0) = 1\&.0f + _trace;
360     q(1) = m(2, 1) - m(1, 2);
361     q(2) = m(0, 2) - m(2, 0);
362     q(3) = m(1, 0) - m(0, 1);
363     break;
364   case 1:
365     q(0) = m(2, 1) - m(1, 2);
366     q(1) = 1\&.0f + m(0, 0) - m(1, 1) - m(2, 2);
367     q(2) = m(0, 1) + m(1, 0);
368     q(3) = m(2, 0) + m(0, 2);
369     break;
370   case 2:
371     q(0) = m(2, 0) - m(0, 2);
372     q(1) = m(0, 1) + m(1, 0);
373     q(2) = 1\&.0f - m(0, 0) + m(1, 1) - m(2, 2);
374     q(3) = m(1, 2) + m(2, 1);
375     break;
376   default:
377     q(0) = m(1, 0) - m(0, 1);
378     q(1) = m(2, 0) + m(0, 2);
379     q(2) = m(2, 1) + m(1, 2);
380     q(3) = 1\&.0f - m(0, 0) - m(1, 1) + m(2, 2);
381     break;
382   }
383   q\&.normalize();
384 }
.fi
.PP
Referencias drone::m\&.
.SS "void ekf::computeQuaternionFromMCDShepperd (Eigen::Matrix3f & m, Eigen::Vector4f & q)"

.SS "Eigen::Vector3f ekf::computeVectorProjection (const Eigen::Ref< Eigen::Vector3f > & v, const Eigen::Ref< Eigen::Vector3f > & u)"
Rejeita a projecao do vetor v sobre u \&. 
.PP
\fBParâmetros\fP
.RS 4
\fIu\fP Vetor tridimensional 
.br
\fIv\fP Vetor tridimensional 
.RE
.PP
\fBRetorna\fP
.RS 4
v sem a projeção de v sobre u\&. * \fCVector Rejection\fP [Vector Rejection ] 
.RE
.PP

.PP
Definição na linha 130 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
131                                                                           {
132 
133   return (v - v\&.dot(u) * u);
134 }
.fi
.SS "void ekf::conjugate (Eigen::Ref< Eigen::Vector4f > _q)"

.PP
Conjuga o quaternion _q\&. 
.PP
\fBParâmetros\fP
.RS 4
\fI_q\fP 
.RE
.PP

.PP
Definição na linha 400 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
400 { _q\&.tail(3) *= -1\&.0f; }
.fi
.SS "void ekf::integrationQuaternion (Eigen::Vector4f & _quat, const Eigen::Ref< const Eigen::VectorXf > & _gyroscope, float & _dt)"
Integracao de quaternion com mapa exponecial\&. 
.PP
\fBParâmetros\fP
.RS 4
\fI_quat\fP Quaternion q_k 
.br
\fI_giroscopio\fP medidas do giroscópio [Radianos] 
.br
\fI_dt\fP Passo de integração\&.
.RE
.PP
\fBObservação\fP
.RS 4
computa norma para evitar instabilidade
.RE
.PP

.PP
Definição na linha 198 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
200                                        {
208   float _gyroscopeNorm = _gyroscope\&.norm();
209 
210   if (_gyroscopeNorm > TOLERANCE) {
211     Eigen::Vector4f expMap;
212     float _dtGyroscopeNormHalf = 0\&.5f * _dt * _gyroscopeNorm;
213     expMap(0) = cosf(_dtGyroscopeNormHalf);
214     expMap\&.tail(3) = _gyroscope / _gyroscopeNorm * sinf(_dtGyroscopeNormHalf);
215     _quat = multiplyQuaternions(_quat, expMap);
216   }
217 }
.fi
.PP
Referencias multiplyQuaternions() e TOLERANCE\&.
.SS "float ekf::invSqrt (float _x)"

.PP
Calcula o inverso do raiz de um float\&. 
.PP
\fBObservação\fP
.RS 4
Para mais detalhes consulte \fCFast inverse square-root\fP 
.RE
.PP
\fBParâmetros\fP
.RS 4
\fI_x\fP 
.RE
.PP
\fBRetorna\fP
.RS 4
1/sqrt(_x) 
.RE
.PP

.PP
Definição na linha 256 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
256                         {
257   float halfx = 0\&.5f * _x;
258   union {
259     float _y;
260     uint32_t _i;
261   } conv = {\&._y = _x};
262   // float _y = _x;
263   // long i = *(long *)&_y;
264   conv\&._i = 0x5f3759df - (conv\&._i >> 1);
265   // _y = *(float *)&i;
266   conv\&._y *= (1\&.5f - (halfx * conv\&._y * conv\&._y));
267   // segunda iteracao\&.
268   // _y = _y * (1\&.5f - (halfx * _y * _y));
269   return conv\&._y;
270 }
.fi
.PP
Referenciado(a) por AQUA::computeQuaternionMag()\&.
.SS "Eigen::Vector4f ekf::multiplyQuaternions (const Eigen::Ref< Eigen::VectorXf > & p, const Eigen::Ref< Eigen::VectorXf > & q)"

.PP
Produto de quaternions aplicado\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIp\fP Quaternion 
.br
\fIq\fP Vetor tridimensional 
.RE
.PP
\fBRetorna\fP
.RS 4
Quaternion product pq 
.RE
.PP

.PP
Definição na linha 142 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
143                                                                       {
144   Eigen::Vector4f pq;
145   pq(0) = p(0) * q(0) - p(1) * q(1) - p(2) * q(2) - p(3) * q(3);
146   pq(1) = p(0) * q(1) + p(1) * q(0) + p(2) * q(3) - p(3) * q(2);
147   pq(2) = p(0) * q(2) - p(1) * q(3) + p(2) * q(0) + p(3) * q(1);
148   pq(3) = p(0) * q(3) + p(1) * q(2) - p(2) * q(1) + p(3) * q(0);
149   return pq;
150 }
.fi
.PP
Referenciado(a) por AQUA::computeAQUAQuaternion() e integrationQuaternion()\&.
.SS "void ekf::printEigen (const Eigen::MatrixXf & m)"
Imprime um dado Eigen\&. Matriz ou vetor\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIm\fP dado a ser impresso\&. 
.RE
.PP

.PP
Definição na linha 111 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
111                                         {
112   int c = m\&.cols();
113   int l = m\&.rows();
114   for (int i = 0; i < l; i++) {
115     for (int j = 0; j < c; j++) {
116       // printf("%f\t", m(i, j));
117       printf(",%f", m(i, j));
118     }
119     printf("%s\n", ",");
120   }
121 }
.fi
.PP
Referencias drone::m\&.
.SS "Eigen::MatrixXf ekf::Q_l (const Eigen::Ref< Eigen::Vector4f > & q)"
Matrix Left-Quaternion Q 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.RE
.PP
\fBRetorna\fP
.RS 4
Matrix Left Quarternio Q 
.RE
.PP

.PP
Definição na linha 45 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
45                                                     {
46 
47   Eigen::MatrixXf M = Eigen::MatrixXf::Zero(4, 3);
48   M\&.row(0) = -q\&.tail(3);
49   M\&.bottomLeftCorner(3, 3) =
50       q(0) * Eigen::Matrix3f::Identity() + skew(q\&.tail(3));
51   return M;
52 }
.fi
.PP
Referencias skew()\&.
.PP
Referenciado(a) por Controle::computeRotationalTarget()\&.
.SS "Eigen::Vector4f ekf::q_phi (float & theta)"

.PP
Calcula o quaternion de atitude de rotação theta sobre o eixo y\&. 
.PP
\fBParâmetros\fP
.RS 4
\fItheta\fP 
.RE
.PP
\fBRetorna\fP
.RS 4
Eigen::Vector4f Quaternion de rotacao theta 
.RE
.PP

.PP
Definição na linha 286 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
286                                   {
287   return Eigen::Vector4f{cosf(0\&.5f * theta), 0, sinf(0\&.5f * theta), 0};
288 }
.fi
.SS "Eigen::Vector4f ekf::q_psi (float & psi)"

.PP
Calcula o quaternion de atitude de rotação psi sobre o eixo z\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIpsi\fP 
.RE
.PP
\fBRetorna\fP
.RS 4
Eigen::Vector4f Quaternion de rotacao psi 
.RE
.PP

.PP
Definição na linha 295 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
295                                 {
296   return Eigen::Vector4f{cosf(0\&.5f * psi), 0, 0, sinf(0\&.5f * psi)};
297 }
.fi
.SS "Eigen::MatrixXf ekf::Q_r (const Eigen::Ref< Eigen::Vector4f > & q)"
Matrix Right-Quaternion Q 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.RE
.PP
\fBRetorna\fP
.RS 4
Matrix Right Quarternio Q 
.RE
.PP

.PP
Definição na linha 31 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
31                                                     {
32 
33   Eigen::MatrixXf M = Eigen::MatrixXf::Zero(4, 3);
34   M\&.row(0) = -q\&.tail(3);
35   M\&.bottomLeftCorner(3, 3) =
36       q(0) * Eigen::Matrix3f::Identity() - skew(q\&.tail(3));
37   return M;
38 }
.fi
.PP
Referencias skew()\&.
.SS "Eigen::Vector4f ekf::q_theta (float & phi)"

.PP
Calcula o quaternion de atitude de rotação phi sobre o eixo x\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIphi\fP 
.RE
.PP
\fBRetorna\fP
.RS 4
Eigen::Vector4f Quaternion de rotacao phi 
.RE
.PP

.PP
Definição na linha 277 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
277                                   {
278   return Eigen::Vector4f{cosf(0\&.5f * phi), sinf(0\&.5f * phi), 0, 0};
279 }
.fi
.SS "void ekf::quaternion2Euler (Eigen::Ref< Eigen::Vector3f > _euler, const Eigen::Ref< const Eigen::Vector4f > & _q)"
Extrai os ângulos de Euler do quatérnion\&. 
.PP
\fBParâmetros\fP
.RS 4
\fI_euler\fP Vetor de ângulos de Euler\&. 
.br
\fI_q\fP Quatérnion de atitude\&.
.RE
.PP

.PP
Definição na linha 152 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
153                                                                {
159   // calculo de fi
160   calc_phi(_euler(0), _q);
161   // calculo de theta
162   calc_theta(_euler(1), _q);
163   // calculo de psi
164   calc_psi(_euler(2), _q);
165 }
.fi
.PP
Referencias calc_phi(), calc_psi() e calc_theta()\&.
.PP
Referenciado(a) por Controle::computeRotationalTarget() e xTaskLoopFilter()\&.
.SS "Eigen::VectorXf ekf::RK (float h, const Eigen ::Ref< Eigen::VectorXf > & xk, const Eigen ::Ref< Eigen::VectorXf > & u, Eigen::VectorXf  fnEigen::VectorXf x, Eigen::VectorXf u)"

.SS "Eigen::VectorXf ekf::RK (float h, const Eigen ::Ref< Eigen::VectorXf > & xk, const Eigen ::Ref< Eigen::VectorXf > & u, Eigen::VectorXf(fn)(Eigen::VectorXf x, Eigen::VectorXf u)   )"

.PP
Definição na linha 385 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
387                                                                         {
388   Eigen::VectorXf k1(xk\&.rows()), k2(xk\&.rows()), k3(xk\&.rows()), k4(xk\&.rows());
389   k1 = h * (*fn)(xk, u);
390   k2 = h * (*fn)(xk + 0\&.5 * k1, u);
391   k3 = h * (*fn)(xk + 0\&.5 * k2, u);
392   k4 = h * (*fn)(xk + k3, u);
393   return xk + (k1 + 2\&.0f * (k2 + k3) + k4) / 6\&.0;
394 }
.fi
.SS "Eigen::Vector3f ekf::rotateVectorWithQuaternion (Eigen::Vector4f & q, Eigen::Vector3f & v_old)"

.PP
Rotaciona um vetor tridimensional com um quaternion\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.br
\fIv_old\fP vetor a ser rotacionado 
.RE
.PP
\fBRetorna\fP
.RS 4
v_new vetor rotacionado\&. 
.RE
.PP
\fBObservação\fP
.RS 4
A transformação desta forma possui 30 operações (15 produtos e 15 multiplicações\&.)(Rotacao de vetor tridimensional com formalismo de eixo/angulo)[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Performance_comparisons] 
.RE
.PP

.PP
Definição na linha 227 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
228                                                                  {
229   return v_old +
230          2\&.0f * q\&.tail<3>()\&.cross(q\&.tail<3>()\&.cross(v_old) + q(0) * v_old);
231 }
.fi
.SS "Eigen::Vector3f ekf::rotateVectorWithQuaternion_Conjugate (Eigen::Vector4f & q, Eigen::Vector3f & v_old)"

.PP
Rotaciona um vetor tridimensional com um quaternion conjugado\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.br
\fIv_old\fP vetor a ser rotacionado 
.RE
.PP
\fBRetorna\fP
.RS 4
v_new vetor rotacionado\&. 
.RE
.PP
\fBObservação\fP
.RS 4
A trasnfromação desta forma possui 30 operações (15 produtos e 15 multiplicações\&.)(Rotacao de vetor tridimensional com formalismo de eixo/angulo)[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Performance_comparisons] 
.RE
.PP

.PP
Definição na linha 242 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
243                                                                            {
244   return v_old +
245          2\&.0f *
246              (-q\&.tail<3>())\&.cross((-q\&.tail<3>())\&.cross(v_old) + q(0) * v_old);
247 }
.fi
.PP
Referenciado(a) por AQUA::computeAQUAQuaternion()\&.
.SS "Eigen::Matrix4f ekf::S_l (const Eigen::Ref< Eigen::Vector4f > & q)"

.PP
Calcula a Matriz \fILeft-Quaternion\fP a partir do quaternion q\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.RE
.PP
\fBRetorna\fP
.RS 4
mS_l Matrix \fIRight-Quaternion\fP
.RE
.PP
A matrix \fILeft-Quaternion\fP torna possível realizar o produto de quaternions como um produto matricial comum\&. 
.PP
Definição na linha 90 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
90                                                     {
91   Eigen::Matrix4f mS_r = Eigen::Matrix4f::Identity() * q(0);
92   mS_r\&.block<1, 3>(0, 1) = -q\&.segment<3>(1);
93   mS_r\&.block<3, 1>(1, 0) = q\&.segment<3>(1);
94   mS_r\&.block<3, 3>(1, 1) += skew(q\&.segment<3>(1));
95   return mS_r;
96 }
.fi
.PP
Referencias skew()\&.
.PP
Referenciado(a) por Controle::computeRotationalControl()\&.
.SS "Eigen::Matrix4f ekf::S_r (const Eigen::Ref< Eigen::Vector4f > & q)"

.SS "Eigen::Matrix4f ekf::S_r (const Eigen::Ref< Eigen::Vector4f > q)"

.PP
Calcula a Matriz \fIRight-Quaternion\fP a partir do quaternion q\&. 
.PP
\fBParâmetros\fP
.RS 4
\fIq\fP quaternion de atitude 
.RE
.PP
\fBRetorna\fP
.RS 4
mS_r Matrix \fIRight-Quaternion\fP
.RE
.PP
A matrix \fIRight-Quaternion\fP torna possível realizar o produto de quaternions como um produto matricial comum\&. 
.PP
Definição na linha 75 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
75                                                    {
76 
77   Eigen::Matrix4f mS_r = Eigen::Matrix4f::Identity() * q(0);
78   mS_r\&.block<1, 3>(0, 1) = -q\&.segment<3>(1);
79   mS_r\&.block<3, 1>(1, 0) = q\&.segment<3>(1);
80   mS_r\&.block<3, 3>(1, 1) -= skew(q\&.segment<3>(1));
81   return mS_r;
82 }
.fi
.PP
Referencias skew()\&.
.SS "Eigen::Matrix3f ekf::skew (const Eigen::Vector3f & v)"

.PP
Matrix antissimetrica\&. 
.PP
\fBParâmetros\fP
.RS 4
\fI[v]\fP Vetor tridimensional 
.RE
.PP
\fBRetorna\fP
.RS 4
[M] Matrix antissimetrica
.RE
.PP
\fCA matrix antissimetrica\fP torna possivel converter um produto vetorial em produto de matrizes\&. 
.PP
Definição na linha 62 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
.nf
62                                            {
63 
64   Eigen::Matrix3f M = Eigen::Matrix3f::Zero();
65   M << 0, -v(2), v(1), v(2), 0, -v(0), -v(1), v(0), 0;
66   return M;
67 }
.fi
.PP
Referenciado(a) por computeMcdFromQuaternion(), Q_l(), Q_r(), S_l(), S_r() e Drone::updateStateMatrices()\&.
.SH "Variáveis"
.PP 
.SS "\fBAQUA\fP ekf::aqua"
Classe do filtro de Kalman\&. 
.PP
Definição na linha 32 do arquivo EKF\&.cpp\&.
.PP
Referenciado(a) por ekf::EKF::begin()\&.
.SS "const float ekf::TOLERANCE = 1e\-6"

.PP
Definição na linha 24 do arquivo GRUPO_QUAT\&.cpp\&.
.PP
Referenciado(a) por integrationQuaternion()\&.
.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
