.TH "funcoesQuaternion" 3 "Sexta, 17 de Setembro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
funcoesQuaternion
.SH SYNOPSIS
.br
.PP
.SS "Funções"

.in +1c
.ti -1c
.RI "def \fBscrewMatrix\fP (quat)"
.br
.ti -1c
.RI "def \fBmatrixQ\fP (quat, right=False)"
.br
.ti -1c
.RI "def \fBmatrixS\fP (quat, right=False)"
.br
.ti -1c
.RI "def \fBMultQuat\fP (r, q, p)"
.br
.ti -1c
.RI "def \fBconj\fP (q)"
.br
.ti -1c
.RI "def \fBquat2Euler\fP (q, deg=0)"
.br
.ti -1c
.RI "def \fBrotationMatrix\fP (q)"
.br
.ti -1c
.RI "def \fBeulerQuaternion\fP (yaw, pitch, roll, deg=True)"
.br
.in -1c
.SH "Funções"
.PP 
.SS "def funcoesQuaternion\&.conj ( q)"

.PP
.nf
Retorna o conjugado do quaternion q.

Parameters
----------
q : quaternion de atitude.

Returns
-------
p : conjugado do quaternion de atitude q.

.fi
.PP
 
.PP
Definição na linha 89 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
89 def conj(q):
90     """Retorna o conjugado do quaternion q\&.
91 
92     Parameters
93     ----------
94     q : quaternion de atitude\&.
95 
96     Returns
97     -------
98     p : conjugado do quaternion de atitude q\&.
99     """
100     p = 1 * q
101     p[:1] *= -1\&.0
102     return p
103 
104 
.fi
.SS "def funcoesQuaternion\&.eulerQuaternion ( yaw,  pitch,  roll,  deg = \fCTrue\fP)"

.PP
.nf
Calcula o quaternio a partir dos Angulos de Euler.

Parameters
----------
yaw : angulo de guinad [rad]
pitch : angulo de guinad [rad]
roll : angulo de guinad [rad]
deg : se 1 informa que os angulos estao em graus
q : quaternio atitude

.fi
.PP
 
.PP
Definição na linha 144 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
144 def eulerQuaternion(yaw, pitch, roll, deg=True):
145     """Calcula o quaternio a partir dos Angulos de Euler\&.
146 
147     Parameters
148     ----------
149     yaw : angulo de guinad [rad]
150     pitch : angulo de guinad [rad]
151     roll : angulo de guinad [rad]
152     deg : se 1 informa que os angulos estao em graus
153     q : quaternio atitude
154     """
155     if deg:
156         yaw *= np\&.pi/180\&.0
157         pitch *= np\&.pi/180\&.0
158         roll *= np\&.pi/180\&.0
159     cy = cos(yaw * 0\&.5)
160     sy = sin(yaw * 0\&.5)
161     cp = cos(pitch * 0\&.5)
162     sp = sin(pitch * 0\&.5)
163     cr = cos(roll * 0\&.5)
164     sr = sin(roll * 0\&.5)
165     q = np\&.zeros(4)
166     q[0] = cr * cp * cy + sr * sp * sy
167     q[1] = sr * cp * cy - cr * sp * sy
168     q[2] = cr * sp * cy + sr * cp * sy
169     q[3] = cr * cp * sy - sr * sp * cy
170     return q
.fi
.SS "def funcoesQuaternion\&.matrixQ ( quat,  right = \fCFalse\fP)"

.PP
.nf
Compute Q matrix.

Parameters
----------
quat : quaternion orientation 4x1
right : boolean. The default is False.

Returns
-------
Q : Q matrix.

.fi
.PP
 
.PP
Definição na linha 32 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
32 def matrixQ(quat, right=False):
33     """Compute Q matrix\&.
34 
35     Parameters
36     ----------
37     quat : quaternion orientation 4x1
38     right : boolean\&. The default is False\&.
39 
40     Returns
41     -------
42     Q : Q matrix\&.
43     """
44     Q = np\&.zeros((4, 3))
45     Q[0, 0] = -quat[1]
46     Q[0, 1] = -quat[2]
47     Q[0, 2] = -quat[3]
48     if right:
49         Q[1:, :] = quat[0]*np\&.identity(3) - screwMatrix(quat)
50     else:
51         Q[1:, :] = quat[0]*np\&.eye(3) + screwMatrix(quat)
52     return Q
53 
54 
.fi
.PP
Referencias screwMatrix()\&.
.PP
Referenciado(a) por matrixS()\&.
.SS "def funcoesQuaternion\&.matrixS ( quat,  right = \fCFalse\fP)"

.PP
.nf
Compute S matrix.

Parameters
----------
quat : quaternion 4x1.
right : boolean, optional. The default is False.

Returns
-------
S : Matrix S.

.fi
.PP
 
.PP
Definição na linha 55 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
55 def matrixS(quat, right=False):
56     """Compute S matrix\&.
57 
58     Parameters
59     ----------
60     quat : quaternion 4x1\&.
61     right : boolean, optional\&. The default is False\&.
62 
63     Returns
64     -------
65     S : Matrix S\&.
66     """
67     S = np\&.zeros((4, 4))
68     if right:
69         S[:, 1:] = matrixQ(quat)
70     else:
71         S[:, 1:] = matrixQ(quat, right=True)
72 
73     S[:, 0] = quat
74     return S
75 
76 
.fi
.PP
Referencias matrixQ()\&.
.SS "def funcoesQuaternion\&.MultQuat ( r,  q,  p)"

.PP
.nf
Parameters.

r, q : quaternion attitude input.
p : result of multiplication.

.fi
.PP
 
.PP
Definição na linha 77 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
77 def MultQuat(r, q, p):
78     """Parameters\&.
79 
80     r, q : quaternion attitude input\&.
81     p : result of multiplication\&.
82     """
83     r[0] = q[0] * p[0] - q[1]*p[1]-q[2]*p[2]-q[3]*p[3]
84     r[1] = q[1] * p[0] + q[0]*p[1]-q[3]*p[2]+q[2]*p[3]
85     r[2] = q[2] * p[0] + q[3]*p[1]+q[0]*p[2]-q[1]*p[3]
86     r[3] = q[3] * p[0] - q[2]*p[1]+q[1]*p[2]+q[0]*p[3]
87 
88 
.fi
.SS "def funcoesQuaternion\&.quat2Euler ( q,  deg = \fC0\fP)"

.PP
.nf
Parameters.

q : quaternion attitude.
deg : TYPE, optional
    DESCRIPTION. 1 to return in degrees. The default is 0.

Returns
-------
TYPE
    DESCRIPTION.
e : 3x1 euler angles

.fi
.PP
 
.PP
Definição na linha 105 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
105 def quat2Euler(q, deg=0):
106     """Parameters\&.
107 
108     q : quaternion attitude\&.
109     deg : TYPE, optional
110         DESCRIPTION\&. 1 to return in degrees\&. The default is 0\&.
111 
112     Returns
113     -------
114     TYPE
115         DESCRIPTION\&.
116     e : 3x1 euler angles
117     """
118     e = np\&.array([0\&., 0\&., 0\&.])
119     e[0] = np\&.arctan2(q[0]*q[1]+q[2]*q[3], q[0]**2+q[3]**2-0\&.5)
120     e[1] = np\&.arcsin(2*(q[0]*q[2]-q[1]*q[3]))
121     e[2] = np\&.arctan2(q[0]*q[3]+q[1]*q[2], q[0]**2+q[1]**2-0\&.5)
122     if deg:
123         return 180\&.0*e/np\&.pi
124     else:
125         return e
126 
127 
.fi
.SS "def funcoesQuaternion\&.rotationMatrix ( q)"

.PP
.nf
Computa a matriz de rotacao a partir do quaternio de attitude.

Parameters
----------
q : quaternion de atitude.

Returns
-------
Matrix de rotacao

.fi
.PP
 
.PP
Definição na linha 128 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
128 def rotationMatrix(q):
129     """Computa a matriz de rotacao a partir do quaternio de attitude\&.
130 
131     Parameters
132     ----------
133     q : quaternion de atitude\&.
134 
135     Returns
136     -------
137     Matrix de rotacao
138     """
139     return (np\&.eye(3)*(q[0]*q[0] - np\&.dot(q[1:], q[1:]))
140             + 2\&.0*q[0] * screwMatrix(q)
141             + 2\&.0 * q[1:]\&.reshape(3, 1)@q[1:]\&.reshape(1, 3))
142 
143 
.fi
.PP
Referencias screwMatrix()\&.
.SS "def funcoesQuaternion\&.screwMatrix ( quat)"

.PP
.nf
Computa a matriz anti-simetrica a partir do quaternion quat.

Parameters
----------
quat : quanternio de atitude.

Returns
-------
q_x : 3x3 matrix anti-simetrica

.fi
.PP
 
.PP
Definição na linha 11 do arquivo funcoesQuaternion\&.py\&.
.PP
.nf
11 def screwMatrix(quat):
12     """Computa a matriz anti-simetrica a partir do quaternion quat\&.
13 
14     Parameters
15     ----------
16     quat : quanternio de atitude\&.
17 
18     Returns
19     -------
20     q_x : 3x3 matrix anti-simetrica
21     """
22     q_x = np\&.zeros((3, 3))
23     q_x[0, 1] = -quat[3]
24     q_x[1, 0] = quat[3]
25     q_x[0, 2] = quat[2]
26     q_x[2, 0] = -quat[2]
27     q_x[1, 2] = -quat[1]
28     q_x[2, 1] = quat[1]
29     return q_x
30 
31 
.fi
.PP
Referenciado(a) por matrixQ() e rotationMatrix()\&.
.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
