.TH "Sdre" 3 "Segunda, 25 de Outubro de 2021" "Quadrirrotor" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Sdre
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Sdre\&.h>\fP
.SS "Membros Públicos"

.in +1c
.ti -1c
.RI "\fBSdre\fP (Eigen::MatrixXf &A, Eigen::MatrixXf &B, Eigen::MatrixXf &\fBQ\fP, Eigen::MatrixXf &\fBR\fP)"
.br
.ti -1c
.RI "\fB~Sdre\fP ()"
.br
.ti -1c
.RI "bool \fBupdateControl\fP ()"
.br
.ti -1c
.RI "Eigen::MatrixXcf \fBcloseLoopEig\fP ()"
.br
.in -1c
.SS "Campos de Dados"

.in +1c
.ti -1c
.RI "Eigen::MatrixXf * \fBphi\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf * \fBgamma\fP"
.br
.ti -1c
.RI "\fBRiccati\fP * \fBricObj\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf * \fBR\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf * \fBQ\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBL\fP"
.br
.ti -1c
.RI "Eigen::MatrixXf \fBE\fP"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Definição na linha 21 do arquivo Sdre\&.h\&.
.SH "Construtores e Destrutores"
.PP 
.SS "Sdre::Sdre (Eigen::MatrixXf & A, Eigen::MatrixXf & B, Eigen::MatrixXf & _Q, Eigen::MatrixXf & _R)"

.PP
\fBAutor\fP
.RS 4
: roney 
.RE
.PP
\fBData\fP
.RS 4
: 2021-08-03T17:16:37-03:00 email: roneyddasilva@gmail.com @File: \fBSdre\&.cpp\fP Last modified by: roney Last modified time: 2021-08-03T17:16:37-03:00 
.RE
.PP

.PP
Definição na linha 10 do arquivo Sdre\&.cpp\&.
.PP
.nf
11                               {
12   int n = A\&.cols();
13   int r = B\&.cols();
14   L = Eigen::MatrixXf::Identity(r, n);
15   Q = &_Q;
16   R = &_R;
17   /* instancia o Solver de Riccati */
18   ricObj = new Riccati(A, B, *Q, *R);
19   /* Salvas os endereços das matrizes de estado e controle*/
20   phi = &A;
21   gamma = &B;
22   E = B * _R\&.inverse() * B\&.transpose();
23 #ifdef COMPUTE_MAT_REALIMENTACAO
24   G = Eigen::MatrixXf::Identity(n, n);
25 #endif
26 }
.fi
.PP
Referencias E, gamma, L, phi, Q, R e ricObj\&.
.SS "Sdre::~Sdre ()"

.PP
Definição na linha 27 do arquivo Sdre\&.cpp\&.
.PP
.nf
27 {}
.fi
.PP
Referenciado(a) por Controle::Controle()\&.
.SH "Funções membros"
.PP 
.SS "Eigen::MatrixXcf Sdre::closeLoopEig ()"
[\fBSdre::closeLoopEig\fP description] 
.PP
Definição na linha 55 do arquivo Sdre\&.cpp\&.
.PP
.nf
55                                   {
56   // Eigen::MatrixXf closeLoop =
57   //     *phi - *gamma * (*R)\&.inverse() * (*gamma)\&.transpose() * (*ricObj)\&.K;
58   Eigen::MatrixXf closeLoop = *phi - *gamma * L;
59   Eigen::EigenSolver<Eigen::MatrixXf> Eigs(closeLoop);
60   return Eigs\&.eigenvalues();
61 };
.fi
.PP
Referencias gamma, L e phi\&.
.PP
Referenciado(a) por Controle::Controle()\&.
.SS "bool Sdre::updateControl ()"
Atualiza a solução de \fBRiccati\fP e o controle ótimo L\&. 
.PP
\fBRetorna\fP
.RS 4
true para sucesso ou false para fracasso\&. 
.RE
.PP

.PP
Definição na linha 32 do arquivo Sdre\&.cpp\&.
.PP
.nf
32                          {
33   // Verifica o se o algoritmo converge com o numero de iterações e tolerância
34   // desejado\&.
35   if ((*ricObj)\&.dareInteration()) { // Obtem a matriz de Riccati\&.
36     // atualiza a matriz de ganho de Kalman
37     L = (*ricObj)\&.Ls * (*ricObj)\&.K * (*phi);
38 #ifdef COMPUTE_MAT_REALIMENTACAO
39     G = ((*ricObj)\&.I -
40          (*phi)\&.transpose() *
41              ((*ricObj)\&.I -
42               (*ricObj)\&.K * ((*ricObj)\&.I + E * (*ricObj)\&.K)\&.inverse() * E))
43             \&.inverse();
44 #endif
45     return true;
46   } else {
47     // Retorna falso mantendo o ultimo ganho de Riccati\&.
48     return false;
49   }
50 }
.fi
.PP
Referencias E e L\&.
.PP
Referenciado(a) por Controle::computeRotationalControl() e Controle::Controle()\&.
.SH "Campos"
.PP 
.SS "Eigen::MatrixXf Sdre::E"
Matrix E = B R^-1 B' 
.PP
Definição na linha 38 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por Sdre() e updateControl()\&.
.SS "Eigen::MatrixXf* Sdre::gamma"
Ponteiro da matriz de controle\&. 
.PP
Definição na linha 28 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por closeLoopEig() e Sdre()\&.
.SS "Eigen::MatrixXf Sdre::L"
Matrix do ganho de Kalman\&. 
.PP
Definição na linha 36 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por closeLoopEig(), Controle::computeRotationalControl(), Controle::Controle(), Sdre() e updateControl()\&.
.SS "Eigen::MatrixXf* Sdre::phi"
Ponteiro da matriz de estado\&. 
.PP
Definição na linha 26 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por closeLoopEig() e Sdre()\&.
.SS "Eigen::MatrixXf* Sdre::Q"
Matrix ponderação dos estados\&. 
.PP
Definição na linha 34 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por Sdre()\&.
.SS "Eigen::MatrixXf* Sdre::R"
Matrix ponderação dos controle\&. 
.PP
Definição na linha 32 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por Sdre()\&.
.SS "\fBRiccati\fP* Sdre::ricObj"
Ponteiro para o solver da equação de \fBRiccati\fP 
.PP
Definição na linha 30 do arquivo Sdre\&.h\&.
.PP
Referenciado(a) por Controle::Controle() e Sdre()\&.

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para Quadrirrotor a partir do código-fonte\&.
