digraph "Controle"
{
 // LATEX_PDF_SIZE
  bgcolor="transparent";
  edge [fontname="DejaVuSansMono",fontsize="8",labelfontname="DejaVuSansMono",labelfontsize="8"];
  node [fontname="DejaVuSansMono",fontsize="8",shape=record];
  Node1 [label="{Controle\n|+ Eigen::Vector3f eulerTarget\l+ int minimalDigitalCommand\l+ int maximalDigitalCommand\l+ float gravidade\l+ uint8_t index_alt\l+ Eigen::Vector3f r\l+ Eigen::Matrix\< float,\l 4, 2 \> qa\l+ Eigen::Vector4f qe\l+ Eigen::Vector3f wa\l+ float psi\l+ float diffPsi\l+ Eigen::Vector3f rI\l+ Eigen::Matrix\< float,\l 3, 6 \> Lt\l+ Eigen::MatrixXf Qt\l+ Eigen::MatrixXf Rt\l+ Eigen::MatrixXf Rr\l+ Eigen::MatrixXf Qr\l+ Eigen::Vector3f ut\l+ Eigen::Vector4f u\l+ Eigen::Vector4i motorCommands\l+ Eigen::Vector4f rotations\lOfMotors\l+ float oldPsi\l+ bool negative_q0\l+ float TSum\l|+  Controle(float discrete\lTime)\l+ void computeTranslational\lControl()\l+ void computeRotationalControl()\l+ void computeRotationalTarget()\l+ void virtualCommandToMotor\lCommand()\l+ void virtualCommandToMotor\lRpm()\l+ void controlLoop()\l}",height=0.2,width=0.4,color="black", fillcolor="grey75", style="filled", fontcolor="black",tooltip=" "];
  Node2 -> Node1 [color="grey25",fontsize="8",style="solid",label=" +sdre" ,arrowhead="odiamond",fontname="DejaVuSansMono"];
  Node2 [label="{Sdre\n|+ Eigen::MatrixXf * phi\l+ Eigen::MatrixXf * gamma\l+ Eigen::MatrixXf * R\l+ Eigen::MatrixXf * Q\l+ Eigen::MatrixXf L\l+ Eigen::MatrixXf E\l|+  Sdre(Eigen::MatrixXf\l &A, Eigen::MatrixXf\l &B, Eigen::MatrixXf &Q,\l Eigen::MatrixXf &R)\l+  ~Sdre()\l+ bool updateControl()\l+ Eigen::MatrixXcf closeLoop\lEig()\l}",height=0.2,width=0.4,color="black",URL="$classSdre.html",tooltip=" "];
  Node3 -> Node2 [color="grey25",fontsize="8",style="solid",label=" +ricObj" ,arrowhead="odiamond",fontname="DejaVuSansMono"];
  Node3 [label="{Riccati\n|+ Eigen::MatrixXf K\l+ Eigen::MatrixXf K_new\l+ Eigen::MatrixXf * phi\l+ Eigen::MatrixXf * gamma\l+ Eigen::MatrixXf * R\l+ Eigen::MatrixXf * Q\l+ Eigen::MatrixXf I\l+ Eigen::MatrixXf Ls\l+ int num_iterations\l|+  Riccati(Eigen::MatrixXf\l &A, Eigen::MatrixXf &B,\l Eigen::MatrixXf &Q, Eigen\l::MatrixXf &R)\l+ bool dareInteration\l(const float &tolerance\l=1.0E-4, const uint16_t\l iter_max=50)\l}",height=0.2,width=0.4,color="black",URL="$classRiccati.html",tooltip=" "];
  Node4 -> Node1 [color="grey25",fontsize="8",style="solid",label=" +drone" ,arrowhead="odiamond",fontname="DejaVuSansMono"];
  Node4 [label="{Drone\n|+ Eigen::Matrix4f J\l+ Eigen::Matrix4f JInverse\l+ float dt\l+ float dx\l+ float massa\l+ const Eigen::DiagonalMatrix\l\< float, 3 \> matrizInercia\l+ const Eigen::DiagonalMatrix\l\< float, 3 \> inverseMatrizInercia\l+ Eigen::Vector3f p\l+ Eigen::Vector3f v\l+ Eigen::Vector4f q\l+ Eigen::Vector3f w\l+ Eigen::MatrixXf matAT\l+ Eigen::MatrixXf matBT\l+ Eigen::MatrixXf matAR\l+ Eigen::MatrixXf matBR\l+ const Eigen::DiagonalMatrix\l\< float, 4 \> H\l+ const Eigen::DiagonalMatrix\l\< float, 4 \> HInverse\l+ const Eigen::Vector4f h\l+ int flagSDC\l- const float L\l- float half_dt\l|+  Drone(float _dt)\l+ void updateStateMatrices\l(bool &negativeq0)\l+ void constructJ()\l}",height=0.2,width=0.4,color="black",URL="$classDrone.html",tooltip=" "];
}
